#command/三剑客
# grep命令--擅长查找

grep命令家族有 grep、egrep、fgrep 三个子命令，适用于不通的场景，具体如下：

```bash
1.grep  原生的grep命令，使用“标准正则表达式”作为匹配标准
2.egrep 扩展的grep命令，相当于 $(grep -E) ，使用“扩展正则表达式”作为匹配标准
3.fgrep 简化版的grep命令，不支持正则表达式，但搜索速度快，系统资源使用率低
```

**基本语法**

`grep [OPTIONS] PATTERN [FILE...]`

```bash
##########  OPTIONS 部分  ##########
-i  # 忽略大小写
-n  # 显示匹配的行号
-c  # 统计匹配的行数
-v  # 显示没有被模式匹配到的行
-o  # 只显示被模式匹配到的字符串
-q  # 静默模式，不输出任何信息
-A  # after,后 # 行
-B  # before,前 # 行
-C  # context，前后各 # 行
-e  # 实现多个选项间的逻辑or关系
-w  # 匹配整个单词
-E  # 使用扩展的正则表达式，egrep = grep -E
-F  # 相当于fgrep，不支持正则表达式
##########  PATTERN 部分  ##########
# 以字符串的形式来给定匹配模板，可以使用普通字符串以及正则表达式（标准&扩展）

##########   FILE 部分  ###########
# 需要查找内容的文件
```

***

# sed命令--擅长取行和替换

sed是一种流编辑器，**它一次处理一行内容**。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。然后读入下行，执行下一个循环。如果没有使诸如‘D’ 的特殊命令，那会在两个循环之间清空模式空间，但不会清空保留空间。这样不断重复，直到文件末尾。

**基本语法**

`sed [option]  'script'  [input file] ...`

**OPTIONS 部分:**

```bash
-n  # 不输出模式空间中未匹配上的内容stdout到屏幕，即不自动打印
-e  # 可以在sed命令中指定多个script脚本，多点编辑功能
-f  # 输入sed脚本，脚本中写着编辑命令
-r  # 支持使用扩展的正则表达式
-i  # 直接编辑源文件


```

**script 部分:**

1.不给地址：对全文进行处理
2.单地址：

```bash
n # 指定的第n行
$ # 最后一行
/pattern/  # 被此模式所能够匹配到的每一行

```

3.地址范围：

```bash
n,m   # 定位从第n行开始至第m行（都是闭区间）
n,+k  # 定位从第n行开始，包括往后的k行
n,/pattern/   # 定位从第n行开始，至指定模式匹配到的那一行
/pattern1/,/pattern2/   # 定位从 pattern1 模式匹配开始，直到 pattern2 模式匹配之间的范围
```

4.步进方式：

```bash
1~2  # 以1为起始行，然后步进2行向下匹配，即所有的奇数行
2~2  # 以2为起始行，然后步进2行向下匹配，即所有的偶数行
```

5.编辑命令：

```bash
d  # 删除模式空间匹配的行，并立即启用下一轮循环
p  # 打印当前模式空间的内容，追加到默认输出之后
3a\text  # 在第三行的下一行追加文本text，支持使用\n实现多行追加
3i\text  # 在第三行的上一行追加文本text
3c\text  # 将第三行替换行为单行或多行文本
w /path/somefile  # 保存模式匹配的行至指定文件
r /path/somefile  # 读取指定文件的文本至模式空间中匹配到的行后
=   # 为模式空间中的行打印行号
！  # 模式空间中匹配行取反处理
s///  # 查找替换，支持使用其他分隔符
        
替换标记： 
g -- 行内全局替换
p -- 显示替换成功的行

```

实践：

```bash
# 删除匹配行的下一行
sed -i '/location/{n;d}' $BASE_PATH/nginx/conf/nginx.conf 
# 在匹配行的下方插入
sed -i '/location/a\xxxxxxxxxxx/;'  /data/nginx/conf/nginx.conf
# 匹配多行，替换其中某行
sed -i  "/datasource/,/username/{s/password.*$/password :Ninestar2022/;s/username.*$/username: jy2web/;s/url.*$/url :jdbc:oracle:thin:@192.168.10.118:1521:orcl/}" budget 

```

# awk--擅长取列

sed读取一行，以行作为单位，进行处理。

awk读取一行，切割成字段，以字段为单位，进行细节处理。

sed的核心是**正则**，awk的核心是**格式化**.

**基本语法**

`awk [option] 'PATTERN{ACTION STATEMENTS}' FILE`

**option部分：**

```bash
-F   # 指明输入字段的分隔符
-v   # 用来实现自定义变量   var=value
```

**PATTERN**

```bash
``         # 表示处理文件的所有行
/pattern/  # 表示处理正则匹配对应的行
!/pattern/ # 表示处理正则不匹配的行
关系表达式   # 比如返回布尔类型的表达式，若结果为真则处理，假则不处理。对于非0非空字符串为真，其余为假
n          #  表示处理第n行的文本
BEGIN/END模式 # 
             # BEGIN{}表示仅在开始处理文件中的文本之前执行一次的程序，例如打印表头
             # END{}表示文本处理完成之后执行一次，例如汇总数据
```

**内建变量**

```bash
FS   # 输入字段分隔符，默认为空白字符。使用-v指定。
OFS  # 输出字段分隔符。
RS   # 输入时的换行符
ORS  # 输出时的换行符
NF   # 每一行的字段数量。加上$NF表示最后一列。
NR   # 文件的行数，打印出来是打印行号
FNR  # 多个文件中的行数分别计数
FILENAME # 当前文件的文件名
ARGC # 参数命令行中参数的个数
ARGV # 返回数组，命令行中的每个参数

# 示例：
awk 'BEGIN {print ARGV[0]}' /etc/fstab /etc/issue
# 此处ARGV[0] 是awk，固定为第0个参数。ARGV[1]是/etc/fstab，ARGV[2]是/etc/issue

awk -v FS=':' '{print $1}'  OFS=':' /etc/passwd
# 指明冒号作为输入及输出的分隔符。同awk -F:...
```

# 扩展-格式化打印（printf）

**语法：**

`printf` `[format] [文本1] [文本2] ..`

**常用格式替换符：**

```bash
%s      # 字符串  
%f      # 浮点格式  
%c      # ASCII字符，即显示对应参数的第一个字符  
%d,%i   # 十进制整数  
%o      # 八进制值  
%u      # 不带正负号的十进制值  
%x      # 十六进制值（a-f）  
%X      # 十六进制值（A-F）  
%%      # 表示%本身
```

**常用转义字符：**

```bash
\a      # 警告字符，通常为ASCII的BEL字符  
\b      # 后退  
\f      # 换页  
\n      # 换行  
\r      # 回车  
\t      # 水平制表符  
\v      # 垂直制表符  
\\      # 表示\本身
```
