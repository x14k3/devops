
反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。

反向代理和正向代理的区别就是：**正向代理代理客户端，反向代理代理服务器。**

```nginx
# proxy_pass 后面有“/”
location /test/ {
    proxy_pass http://127.0.0.1/; 
}
# 访问www.doshell.cn:8001/test/
# 会被映射请求为
# 127.0.0.1/

# proxy_pass 后面没有“/”
location /test/ {
    proxy_pass http://127.0.0.1; 
}
# 访问www.doshell.cn:8001/test/
# 会被映射请求为
# 127.0.0.1/test/

```


## Nginx反向代理缓存配置

### 定义缓存区域

在`http`块中通过`proxy_cache_path`指令定义缓存存储路径和参数：

```nginx
http {
    # 定义缓存区域
    # 参数说明：
    # levels=1:2 - 两级目录结构
    # keys_zone=my_cache:10m - 共享内存区名称和大小
    # inactive=60m - 60分钟未访问则删除缓存
    # max_size=1g - 最大缓存空间
    proxy_cache_path /var/cache/nginx 
        levels=1:2 
        keys_zone=my_cache:10m 
        inactive=60m 
        max_size=1g;
}
```

### 反向代理配置

```nginx
server {
    listen 80;
    server_name example.com;

    location / {
        # 引用缓存区域
        proxy_cache my_cache;
        
        # 定义缓存键（按请求URI和Host头区分）
        proxy_cache_key "$host$uri";
        
        # 设置不同状态码的缓存时间
        proxy_cache_valid 200 301 302 1h;  # 成功响应缓存1小时
        proxy_cache_valid 404 5m;          # 错误缓存5分钟
        
        # 反向代理到后端服务
        proxy_pass http://backend_server;
    }
}
```

### 关键参数说明

| 参数 | 作用 | 示例值 |
| --- | --- | --- |
| `proxy_cache_path` | 定义缓存存储路径和参数 | `/var/cache/nginx levels=1:2 keys_zone=my_cache:10m` |
| `proxy_cache` | 指定使用的缓存区域 | `my_cache` |
| `proxy_cache_key` | 定义缓存键的生成规则 | `"$host$uri"` |
| `proxy_cache_valid` | 设置不同状态码的缓存时间 | `200 302 10m` |
| `proxy_ignore_headers` | 忽略后端返回的缓存控制头 | `Cache-Control Expires` |


## 进阶配置场景

### 动态内容不缓存

对API接口或动态页面禁用缓存：

```nginx
location /api/ {
    proxy_pass http://backend_server;
    proxy_cache off;  # 显式关闭缓存
}
```

### 缓存穿透保护

当请求不存在的资源时，避免频繁访问后端：

```nginx
location / {
    proxy_cache my_cache;
    proxy_cache_valid 404 5m;  # 对404错误缓存5分钟
    proxy_pass http://backend_server;
}
```

### 强制刷新缓存

通过请求头控制缓存行为：

```nginx
map $http_cache_control $no_cache {
    default 0;
    "~no-cache" 1;
}

server {
    location / {
        proxy_cache my_cache;
        proxy_no_cache $no_cache;  # 当请求头包含no-cache时不缓存
        proxy_pass http://backend_server;
    }
}
```

### 手动清理缓存

使用命令清理缓存文件：

```bash
rm -rf /var/cache/nginx/*
```


## proxy\_pass url 反向代理的坑

说到 Nginx 就不得不说 Nginx 的反向代理是多么的好用，一个指令 `proxy_pass`​ 搞定反向代理，对于接口代理、负载均衡很是实用，但 `proxy_pass`​ 指令后面的参数很有讲究。

```nginx
####### minio
        location ~^/obsidian {
            proxy_pass http://127.0.0.1:9000;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $http_host;
        }

####### gotify
        location /gotify/ {
            proxy_pass http://127.0.0.1:8903;
            rewrite ^/gotify(/.*) $1 break;
            proxy_http_version 1.1;
            # Ensuring it can use websockets
            proxy_set_header   Upgrade $http_upgrade;
            proxy_set_header   Connection "upgrade";
            proxy_set_header   X-Real-IP $remote_addr;
            proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header   X-Forwarded-Proto http;
            proxy_redirect     http:// $scheme://;
            # The proxy must preserve the host because gotify verifies the host with the origin
            # for WebSocket connections
            proxy_set_header   Host $http_host;
        }

######## v2ray
        location /vvmess {
            proxy_redirect off;
            proxy_pass http://127.0.0.1:9002;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $http_host;
            limit_conn conn_zone 100;
        }
```