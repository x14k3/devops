
## 1. OOM简介
OOM是Out Of Memory的缩写。即内存溢出。OOM通常是由于程序消耗的内存超过了系统实际可用的内存资源，或者是内存泄漏导致的。OOM错误会导致程序异常终止，通常会在日志或控制台中输出相关错误信息，包括堆栈跟踪等，以便开发人员进行排查和修复。解决OOM问题通常需要对程序进行内存使用情况的分析，优化代码逻辑，释放不必要的内存资源，增加系统内存配置等措施。

## 2. 发生OOM原因

- 内存泄漏：程序中存在内存泄漏问题，即申请的内存未被正确释放。长时间运行的程序中，如果频繁创建对象而不释放，就会导致内存不断累积，最终耗尽可用内存，触发OOM错误。
- 内存申请过大：程序在某一时刻申请了过多的内存，超出了系统实际可用内存资源。这可能是由于算法设计不当、数据结构选择不合适等原因导致的，也可能是程序本身存在缺陷。
- 内存资源被占用过多：系统中其他进程或服务占用了大量内存资源，导致当前程序无法获得足够的内存空间。

## 3. 哪些区域会OOM

[[中间件/jdk/assets/1900341bb6aa6e45b91a40abe2f1dcf1_MD5.jpg|Open: Pasted image 20251119150951.png]]
![[中间件/jdk/assets/1900341bb6aa6e45b91a40abe2f1dcf1_MD5.jpg]]
在Java虚拟机中，通常发生OOM的区域包括：

- 堆内存（Heap）：堆内存是Java程序中用于存储对象实例的区域，如果堆内存不足以存储新的对象实例，就会触发OutOfMemoryError。
- 方法区（Method Area）：方法区用于存储类的结构信息、静态变量、常量池等数据。如果方法区无法满足新的类加载、常量存储等需求，就会导致OutOfMemoryError。
- 栈内存（Stack）：栈内存用于存储线程私有的方法调用栈、局部变量等信息。如果线程调用的方法层次太深，栈内存不足，就会抛出StackOverflowError。虽然不是严格意义上的OOM，但也是一种内存相关的错误。
- 本地方法栈（Native Method Stack）：本地方法栈类似于Java栈，但是用于执行Native方法（即用C、C++等语言编写的方法）。如果Native方法调用层次太深，本地方法栈不足，就会抛出StackOverflowError。
- 直接内存（Direct Memory）：直接内存是一种使用NIO库进行I/O操作时可能使用的一种内存，它并不受Java虚拟机内存管理系统的管理，因此也有可能发生OOM。

## 4. JVM挂掉原因

内存溢出（OOM）：内存溢出是最常见的导致JVM崩溃的原因之一，当堆内存、方法区或者栈空间无法满足程序的内存需求时，会触发OOM错误导致JVM崩溃。
栈溢出（StackOverflowError）：如果方法调用的递归层次过深，导致栈空间耗尽，就会触发栈溢出错误。
内存泄漏：即使没有OOM或者栈溢出，如果程序存在内存泄漏，长时间运行下来内存消耗可能会越来越高，最终耗尽所有可用内存导致JVM崩溃。
死锁：如果程序中存在死锁，所有线程都被阻塞，无法继续执行下去，最终导致JVM挂掉。
本地方法异常：如果程序调用了本地方法，而本地方法抛出了异常并没有被捕获处理，可能会导致JVM挂掉。
硬件故障：硬件故障包括服务器硬件损坏、网络中断等，可能导致JVM无法正常运行。
虚拟机错误：JVM本身存在bug或者配置不当，可能导致JVM挂掉。
操作系统错误：操作系统出现异常或者系统资源不足，也可能导致JVM崩溃。

## 5. 生产环境中如何快速定位问题

首先要确认是否是由于系统资源不足导致的JVM被Linux系统杀死，如果是，可以尝试释放一些资源以减轻压力。如果不是被系统杀死，就需要进一步分析是不是OOM导致的。在生产环境中，我们主要关注的是直接内存、元空间和堆的OOM问题。通过查看日志文件，可以确定是否有OOM发生，并进一步确认是堆OOM还是元空间OOM。如果有生成dump文件，可以下载下来用VisualVM等工具进行分析，定位具体的OOM位置。如果发现是在创建对象或调用构造方法时出现OOM，那么很可能是堆OOM；而如果发现是在类加载器相关的方法中出现OOM，那么很可能是元空间OOM。

- 直接内存的OOM通常是由于Native内存申请过多导致的，可以通过监控Native内存的使用情况来定位问题。
- 元空间的OOM则可能是由于类加载过多或者元数据占用过大，可以通过查看元空间的使用情况和类加载器的情况来排查。
- 堆的OOM可能是由于内存分配不足或者内存泄漏导致的，可以通过分析堆的使用情况和内存快照来找出问题。

常见的 Java 堆空间的 OOM 排查思路

- jmap -heap：该命令用于查看Java堆的详细信息，包括堆的总体情况、各个区域的使用情况以及GC信息。通过观察堆的大小和使用情况，可以判断是否存在内存分配过小的问题。
- jmap -histo：该命令用于查看Java堆中各个对象的数量和大小统计信息。通过分析对象的分配情况，可以发现是否有某种类型的对象分配过多且没有被释放，从而导致内存泄漏问题。
- jmap -dump：该命令用于导出JVM当前的内存快照，生成一个.hprof文件。可以使用JDK自带的工具或者MAT（Memory Analyzer Tool）等工具来分析这个内存快照文件，进一步了解内存使用情况、对象的引用关系等，从而找出内存问题的根源。