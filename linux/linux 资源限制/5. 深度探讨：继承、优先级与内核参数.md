在前几章中，我们学习了 `ulimit` 命令、`limits.conf` 文件以及 `pam_limits` 模块的基本用法。现在，我们将深入探讨一些更为复杂的概念：资源限制的继承规则、`limits.conf` 文件中不同规则的优先级，以及 Linux 内核参数如何影响资源限制。理解这些内容对于构建健壮、可控的系统至关重要。

### 5.1 资源限制的继承性

进程是 Linux 系统中最基本的执行单位，而资源限制是针对进程而言的。那么，一个新创建的进程会继承哪些资源限制，又是如何继承的呢？

进程的创建通常是通过 `fork()` 系统调用来完成的。当一个进程调用 `fork()` 创建其子进程时，子进程会**继承**父进程的绝大多数属性，这其中就包括资源限制（Resource Limits）。这意味着，如果父进程拥有某个资源限制设置（例如，最大打开文件数），那么其子进程在创建时也会拥有**相同**的限制。

① **ulimit 设置的继承**

当我们使用 `ulimit` 命令在一个 shell 会话中设置资源限制时，这个设置会立即应用于当前的 shell 进程。随后，从这个 shell 进程派生（fork）出来的**所有子进程**（包括通过这个 shell 启动的命令、脚本等），都将继承这个 shell 的资源限制。

例如，如果你在一个 bash 会话中执行 `ulimit -n 1024` 将最大打开文件数设置为 1024，然后在这个 bash 中运行一个 Python 脚本或另一个命令，这个 Python 脚本或命令进程的初始最大打开文件数限制也将是 1024。
```bash
# 查看当前 shell 的文件描述符软限制
ulimit -Sn
# 设置文件描述符软限制为 2048
ulimit -Sn 2048
# 启动一个子 shell，子 shell 将继承父 shell 的限制
bash
# 在子 shell 中查看限制，会看到 2048
ulimit -Sn
exit
# 回到父 shell，限制仍然是 2048
ulimit -Sn
```

需要注意的是，子进程继承的是父进程**当时**的资源限制值。子进程可以在其内部（如果允许的话）通过再次调用类似 `setrlimit()` 的系统调用或者执行 `ulimit` 命令（如果是一个 shell 进程）来修改自己的资源限制。但是，这种修改**不会**影响其父进程或其兄弟进程，只会影响它自己及其后续派生的子进程。

② **资源限制的修改权限**

资源限制分为**软限制 (Soft Limit)** 和**硬限制 (Hard Limit)**。

- **软限制 (Soft Limit)**：可以由进程自身随时修改，但不能超过硬限制。
- **硬限制 (Hard Limit)**：是资源的真正上限。普通用户进程只能**降低**硬限制，一旦降低就不能再升高。只有具有 `CAP_SYS_RESOURCE` 能力（通常是 root 用户）的进程才能**升高**硬限制（最高不能超过系统范围内的硬上限，我们稍后会讲到）。

这就是为什么普通用户可以使用 `ulimit -n 2048` 来降低自己的文件描述符硬限制（如果当前硬限制大于2048），但不能使用 `ulimit -Hn 4096` 来升高它，除非当前硬限制已经大于或等于4096。而 root 用户则可以随意设置软硬限制，只要不超过内核设定的系统级硬上限。

③ **execve() 系统调用的影响**

当一个进程通过 `execve()` 系统调用执行一个新的程序时（例如，执行 `/bin/ls` 命令），原进程的内存空间会被新程序的代码和数据替换。然而，资源限制设置通常会**保留**下来。这意味着通过 `execve()` 启动的新程序会继承调用者进程的资源限制。

这保证了通过 shell 启动的命令（shell 通常会先 `fork`，然后子进程 `execve` 执行命令）会继承 shell 的 `ulimit` 设置。

总结来说，资源限制的继承性确保了在一个受限环境中启动的程序，默认情况下也会受到相同的限制，这有助于维护系统的整体资源管理策略。

### 5.2 limits.conf中的规则优先级

`/etc/security/limits.conf` 文件（以及 `/etc/security/limits.d/` 目录下的文件）允许我们为特定的用户、组或所有用户/组设置持久化的资源限制。然而，一个用户可能属于多个组，或者同时匹配到通配符规则和具体用户规则。当多条规则适用于同一个用户或组时，它们是如何解析和应用的呢？ 

`/etc/security/limits.conf` 文件是由 `pam_limits` 模块在用户登录时解析的。`pam_limits` 模块按照一定的优先级顺序来处理这些规则。理解这个优先级对于正确配置资源限制至关重要。

基本的解析顺序如下：

① **文件加载顺序**

- 首先加载 `/etc/security/limits.conf` 文件。
- 接着加载 `/etc/security/limits.d/` 目录下所有以 `.conf` 结尾的文件，通常按字母顺序加载。

② **规则匹配优先级**

在加载完所有规则后，`pam_limits` 会为当前登录的用户查找匹配的规则。匹配规则的优先级从高到低通常是：

1. **具体的非用户名的规则**：例如 `@group` 规则，优先于用户名的规则。这是因为组规则可以同时应用于多个用户，具有更广泛的影响力，但优先级低于用户规则。
2. **具体的用户名规则**：例如 `username` 规则。这类规则具有最高的优先级，会覆盖适用于该用户所在组或所有用户的规则。
3. **通配符规则 (`*)`)**：适用于所有用户，但优先级最低，会被具体的用户名或组规则覆盖。
4. **通配符规则 (`%`)**：适用于所有组，其行为与 `*` 类似，通常也被具体的组或用户规则覆盖。

③ **同类型规则的处理**

对于同一个用户/组和同一个资源项（`<item>`），可能会有多条匹配的规则（可能来自不同的文件或文件中的不同行）。`pam_limits` 会采用以下策略处理这些规则：

- **硬限制 (hard limit)**：`pam_limits` 会取所有匹配的硬限制中**最低**的值作为最终的硬限制。这是为了确保安全，即使有多条规则，最终的上限也不会被意外提高。
- **软限制 (soft limit)**：`pam_limits` 会取所有匹配的软限制中**最高**的值作为最终的软限制。这是为了提供一定的灵活性，允许用户在不超过最终硬限制的前提下使用更多的资源。

④ **规则示例与解析**

假设 `limits.conf` 或 `limits.d` 文件中有以下规则：
```bash
*        soft    nofile    1024
*        hard    nofile    4096
@users   soft    nofile    2048
@users   hard    nofile    8192
user1    soft    nofile    4096
user1    hard    nofile    65535
```
现在考虑用户 `user1` 登录，假设 `user1` 属于 `users` 组。`pam_limits` 会匹配到所有这三组规则。

- **硬限制 (nofile)**：匹配到 `* hard nofile 4096` 和 `@users hard nofile 8192` 以及 `user1 hard nofile 65535`。取其中的最低值，最终 `user1` 的 hard nofile 限制将是 4096。
- **软限制 (nofile)**：匹配到 `* soft nofile 1024` 和 `@users soft nofile 2048` 以及 `user1 soft nofile 4096`。取其中的最高值，最终 `user1` 的 soft nofile 限制将是 4096。

最终，`user1` 登录后的 `nofile` 限制将是 `soft=4096, hard=4096`。可以看到，具体用户规则的软限制优先级最高，而所有规则中的最低硬限制生效。

这是一个重要的细节！尽管 `user1` 的硬限制规则是 65535，但因为通配符规则的硬限制是 4096，并且硬限制取最低值，所以最终硬限制被拉低到了 4096。因此，在设置硬限制时，需要确保通配符规则不会意外地限制了具体用户或组的上限。或者，通过更精细的规则覆盖来达到目的。

⑤ **`-` 类型的规则**

`-` 类型规则表示同时设置软限制和硬限制。当使用 `-` 类型规则时，它也会参与到上述的软限制取最高和硬限制取最低的计算中。例如：
```bash
*        -       nofile    4096
user1    -       nofile    8192
```

用户 `user1` 登录时，会匹配 `*` 和 `user1` 两条规则。

- 硬限制：取最低值，min(4096, 8192) = 4096。
- 软限制：取最高值，max(4096, 8192) = 8192。  
    最终，`user1` 的限制将是 `soft=8192, hard=4096`。注意，此时软限制超过了硬限制，这是一个**无效**的状态。`pam_limits` 会检测到这种情况，并将软限制自动**降低**到等于硬限制的值。所以最终实际生效的将是 `soft=4096, hard=4096`。

因此，虽然 `-` 类型方便一次设置软硬限制，但在与多条规则混合使用时，需要特别注意最终软硬限制是否一致，否则软限制可能会被强制降低到硬限制的值。建议明确区分 `soft` 和 `hard` 规则以避免混淆。

理解这些优先级和处理规则，是确保你的 `limits.conf` 配置按预期工作的基础。

### 5.3 内核资源限制参数(sysctl)

除了 `ulimit` 和 `limits.conf`，Linux 内核本身也维护了一些系统级别的资源限制参数。这些参数通常通过 `/proc/sys/` 文件系统暴露出来，并可以通过 `sysctl` 命令进行查看和修改。这些内核参数设定的是**整个系统**或**特定资源类型**的全局硬上限，是所有用户和进程资源限制的“天花板”。

资源限制体系可以看作是一个层层过滤的过程：

内核参数 (`/proc/sys`) ➡️ pam_limits (`limits.conf`) ➡️ 进程继承 (`fork`/`execve`) ➡️ 进程自身修改 (`setrlimit`/`ulimit`)

其中，内核参数设定的值是最高层级的硬上限。任何通过 `limits.conf` 或 `ulimit` 设置的硬限制，都不能超过对应的内核参数所设定的值。

一些常见的与资源限制相关的内核参数包括：

① **文件描述符系统级上限**

- `/proc/sys/fs/file-max`：这是整个系统范围内**所有进程**可以同时打开的文件描述符的总数。当达到这个数值时，任何进程都将无法再打开新的文件或套接字，即使该进程自身的 `nofile` 硬限制很高。这是防止文件描述符耗尽导致系统不稳定的重要参数。
    - 查看：`cat /proc/sys/fs/file-max` 或 `sysctl fs.file-max`
    - 修改：`echo 100000 > /proc/sys/fs/file-max` 或 `sysctl -w fs.file-max=100000` (临时)
    - 持久化修改：编辑 `/etc/sysctl.conf` 或 `/etc/sysctl.d/*.conf` 文件，添加 `fs.file-max = 100000`，然后执行 `sysctl -p` 使配置生效。

② **最大进程数系统级上限**

- `/proc/sys/kernel/pid_max`：系统最大进程 ID (PID) 值。当系统创建进程时，PID 会从 1 递增，达到 `pid_max` 后会回绕到 300 并重新使用空闲的 PID。虽然不是直接的资源限制，但它决定了系统理论上能支持的最大进程数量。
    
    - 查看：`cat /proc/sys/kernel/pid_max` 或 `sysctl kernel.pid_max`
    - 修改和持久化方法与 `file-max` 类似。
- `/proc/sys/kernel/threads-max`：这是整个系统范围内可以创建的线程（包括进程本身）的总数。此限制通常与系统内存量相关，限制过多线程可以防止系统因线程资源耗尽而崩溃。进程的 `nproc` 限制（用户最大进程数）不能超过此值。
    
    - 查看：`cat /proc/sys/kernel/threads-max` 或 `sysctl kernel.threads-max`
    - 修改和持久化方法与 `file-max` 类似。

③ **其他相关内核参数**

- `/proc/sys/vm/max_map_count`：限制一个进程可以拥有的内存映射区域的最大数量。对某些需要大量映射文件的应用（如 Elasticsearch）很重要。

这些内核参数设定了系统资源的全局容量。当你通过 `limits.conf` 设置用户的硬限制时，你设置的值不能高于对应的内核参数设定的上限。如果 `limits.conf` 中的硬限制值高于内核参数的限制，实际生效的硬限制将是内核参数的值。

例如，如果 `/proc/sys/fs/file-max` 是 100000，而你在 `limits.conf` 中为某个用户设置了 `* hard nofile 200000`，那么该用户的实际 `nofile` 硬限制将是 100000。

因此，在调整用户或组的资源限制时，如果需要提高硬限制到很高的值，首先需要检查并可能调整相关的内核参数，确保系统具备支撑这些高限制的能力。

### 5.4 资源限制的生效时机

理解不同的资源限制配置方法何时生效，对于故障排除和确保配置按预期工作至关重要。我们总结一下：⏰🔄

① **ulimit 命令**

- **生效时机**：`ulimit` 命令立即对**当前执行命令的 shell 进程**生效。
- **作用范围**：仅影响当前 shell 进程及其**未来派生的子进程**。不影响已经运行的进程，也不影响其他 shell 会话或用户。设置是**临时**的，会话结束后失效。
- **权限要求**：
    - 普通用户可以降低自己的软硬限制（硬限制一旦降低无法升高）。
    - 普通用户可以将软限制提高到不超过硬限制。
    - root 用户可以任意设置软硬限制（硬限制不能超过内核参数设定的系统级上限）。

② **limits.conf 文件 (通过 pam_limits)**

- **生效时机**：当用户通过支持 PAM（可插拔认证模块）的服务（如 `login`, `sshd`, `su` 等）**登录或开启新会话**时，`pam_limits` 模块会被调用，解析 `limits.conf` (及 `limits.d` 目录下的文件) 并应用相应的资源限制。
- **作用范围**：影响通过 PAM 认证登录的用户的整个会话以及该会话中启动的所有进程（它们继承了会话进程的限制）。对于已经运行的进程或未通过 PAM 认证启动的进程（例如在系统启动时作为服务启动的进程，如果其启动脚本没有显式设置限制），`limits.conf` 的更改**不会立即生效**。
- **持久性**：配置是**持久**的，修改文件后，新的登录会话将应用新的限制。对于长期运行的服务，可能需要重启服务才能使limits.conf的更改生效（如果服务在启动时读取了PAM环境或使用了相关的启动脚本）。
- **权限要求**：修改 `/etc/security/limits.conf` 文件通常需要 root 权限。

③ **内核参数 (sysctl)**

- **生效时机**：通过 `sysctl -w` 修改参数是**立即**生效的。通过修改 `/etc/sysctl.conf` 或 `/etc/sysctl.d/*.conf` 文件并通过 `sysctl -p` 使之生效也是立即的。在系统启动时，系统会读取这些配置文件并应用参数。
- **作用范围**：影响**整个系统**，为所有用户和进程设定资源使用的**全局上限**。
- **持久性**：直接使用 `sysctl -w` 是**临时**的，系统重启后会丢失。通过配置文件是**持久**的。
- **权限要求**：修改内核参数通常需要 root 权限。

④ **总结图示**

我们可以简单地将生效时机和作用范围概括如下：

⚝ `ulimit`: **临时**，仅限**当前 shell 及其子进程**。  
⚝ `limits.conf` (via `pam_limits`): **持久**，影响**新登录会话及其进程**。  
⚝ 内核参数 (`sysctl`): **持久或临时**，影响**整个系统**。

```bash
┌──────────────────────────┐
│   Kernel Parameters      │
│   (/proc/sys, sysctl)    │
│   (System-wide Hard Cap) │
└────────────┬─────────────┘
             │
             ▼
┌──────────────────────────┐
│ pam_limits (reads limits.conf) │
│ (Applies on login/session start)│
│ (User/Group/Wildcard Limits) │
└────────────┬─────────────┘
             │
             ▼
┌──────────────────────────┐
│   Parent Process         │
│   (Inherited Limits)     │
└────────────┬─────────────┘
             │
             ▼
┌──────────────────────────┐
│   Child Process          │
│   (Inherits Parent's Limits)│
│   (Can potentially lower)│
└──────────────────────────┘
```

这个层级关系和生效时机图谱有助于理解资源限制如何在不同层面和时间点上发挥作用。

### 5.5 进程的当前资源限制查看

在对资源限制进行配置和故障排除时，查看特定**正在运行**的进程的当前资源限制是非常有用的。这可以帮助我们确认配置是否按预期生效，或者定位资源耗尽是由哪个进程引起的。

Linux 系统提供了几种方法来查看一个进程当前的资源限制。

① **使用 `/proc/[pid]/limits` 文件**

这是最直接也是最权威的方式。Linux 内核通过 `/proc` 文件系统暴露了关于进程的详细信息，每个进程都有一个以其 PID 命名的目录。在该目录下，有一个 `limits` 文件，包含了该进程当前的资源限制信息。

**查看命令**：`cat /proc/<PID>/limits`，将 `<PID>` 替换为你想查看的进程的实际进程 ID。

```bash
# 示例：假设你想查看 PID 为 1234 的进程的资源限制
cat /proc/1234/limits

# 输出示例：输出通常包含软限制 (Soft Limit)、硬限制 (Hard Limit) 和单位 (Units)，格式清晰易读。
Limit                     Soft Limit           Hard Limit           Units
Max cpu time              unlimited            unlimited            seconds
Max file size             unlimited            unlimited            bytes
Max data size             unlimited            unlimited            bytes
Max stack size            8388608              unlimited            bytes
Max core file size        0                    unlimited            bytes
Max resident set          unlimited            unlimited            bytes
Max processes             4096                 4096                 processes
Max open files            1024                 4096                 files
Max locked memory         65536                65536                bytes
Max address space         unlimited            unlimited            bytes
Max file locks            unlimited            unlimited            locks
Max pending signals       4096                 4096                 signals
Max msgqueue sizes        819200               819200               bytes
Max nice priority         0                    0
Max realtime priority     0                    0
Max fsuid                 1000                 1000
Max fsid                  1000                 1000
```

② **使用 `prlimit` 命令**

`prlimit` 是一个专门用于获取和设置特定进程资源限制的命令。它提供了比直接读取 `/proc/[pid]/limits` 更便捷的交互方式，并且支持通过名称指定资源项。

**基本语法**：`prlimit [OPTIONS] [PID]`
```bash
# 查看指定进程的所有限制**：`prlimit <PID>`
# 查看 PID 为 1234 的进程的所有资源限制
prlimit 1234

# 查看指定进程的某个资源限制：`prlimit --resource <resource_name> <PID>`，`<resource_name>` 是资源名称的缩写，例如 `nofile`, `nproc`, `as`, `core` 等。可以使用 `prlimit --help` 查看所有支持的资源名称。
# 查看 PID 为 1234 的进程的打开文件数限制|
prlimit --nofile 1234

# 使用 `prlimit` 修改进程限制（需要相应权限）**：`prlimit --resource <resource_name>=soft:hard <PID>` 或 `prlimit --nofile=10000:20000 <PID>`。请注意，修改其他用户进程的限制通常需要 root 权限，并且受限于硬限制不能提高、内核参数上限等规则。
# 以 root 身份尝试修改 PID 1234 的进程的 nofile 限制|
sudo prlimit --nofile=2048:8192 1234
```
`prlimit` 命令是检查和临时调整运行中进程资源限制的强大工具，尤其在调试和系统维护时非常有用。

通过这两种方法，我们可以方便地了解任何运行中的进程实际生效的资源限制，从而更好地诊断与资源相关的系统问题。