
### stunnel

```bash
#!/bin/bash

# 颜色定义

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

SERVICE_NAME="stunnel"

PID_FILE="/opt/homebrew/etc/stunnel/stunnel.pid"
LOG_FILE="/var/log/${SERVICE_NAME}.log"

#if [[ ! "$EUID" -eq 0 ]]; then
#  echo -e "${YELLOW} 请使用 sudo 提权${NC}"
#  exit 1
#fi

find_pid() {
    local pid=$(cat ${PID_FILE})
    echo $pid
}


# 函数：检查服务状态
check_status() {
    local pid=$(find_pid)
    if [ -n "$pid" ]; then
        # 检查进程是否真的存在
        if kill -0 $pid 2>/dev/null; then
            echo -e "${GREEN}服务 ${SERVICE_NAME} 正在运行 (PID: $pid)${NC}"
        #    # 显示详细进程信息
        #    echo "进程信息:"
        #    ps -p $pid -o pid,ppid,user,%cpu,%mem,cmd --no-headers
        #    
        #    # 检查内存使用
        #    local mem_usage=$(ps -p $pid -o %mem --no-headers | awk '{print $1}')
        #    echo "内存使用: ${mem_usage}%"
        #    
            return 0
        else
            echo -e "${YELLOW}找到PID但进程不存在，可能已异常退出${NC}"
            return 1
        fi
    else
        echo -e "${RED}服务 ${SERVICE_NAME} 未运行${NC}"
        return 1
    fi
}


# 函数：启动服务
start_service() {
    echo -e "${BLUE}正在启动 ${SERVICE_NAME}...${NC}"
    # 检查是否已在运行
    if check_status > /dev/null 2>&1; then
        echo -e "${YELLOW}服务 ${SERVICE_NAME} 已在运行中${NC}"
        return 0
    fi
    # 这里需要根据具体服务修改启动命令
    stunnel
    # 等待进程启动
    sleep 2
    # 检查启动结果
    if check_status > /dev/null 2>&1; then
        local pid=$(find_pid)
        echo $pid > "$PID_FILE"
        echo -e "${GREEN}服务 ${SERVICE_NAME} 启动成功 (PID: $pid)${NC}"
        return 0
    else
        echo -e "${RED}服务 ${SERVICE_NAME} 启动失败${NC}"
        return 1
    fi
}

  

# 函数：停止服务
stop_service() {
    echo -e "${BLUE}正在停止 ${SERVICE_NAME}...${NC}"
    local pid=$(find_pid)
    if [ -z "$pid" ]; then
        echo -e "${YELLOW}服务 ${SERVICE_NAME} 未在运行${NC}"
        return 0
    fi

    # 先尝试优雅停止
    echo "尝试优雅停止..."
    kill -TERM $pid 2>/dev/null
    # 等待最多10秒
    local wait_time=0
    while [ $wait_time -lt 10 ]; do
        if ! kill -0 $pid 2>/dev/null; then
            echo -e "${GREEN}服务 ${SERVICE_NAME} 已优雅停止${NC}"
            rm -f "$PID_FILE"
            return 0
        fi
        sleep 1
        ((wait_time++))
    done
    # 强制停止
    echo "强制停止..."
    kill -KILL $pid 2>/dev/null
    sleep 1
    if ! kill -0 $pid 2>/dev/null; then
        echo -e "${GREEN}服务 ${SERVICE_NAME} 已强制停止${NC}"
        rm -f "$PID_FILE"
        return 0
    else
        echo -e "${RED}无法停止服务 ${SERVICE_NAME}${NC}"
        return 1
    fi
}

# 函数：重启服务
restart_service() {
    echo -e "${BLUE}正在重启 ${SERVICE_NAME}...${NC}"
    stop_service
    sleep 2
    start_service
}

# 根据命令执行相应操作
case $1 in
    start)
        start_service
        ;;
    stop)
        stop_service
        ;;
    restart)
        restart_service
        ;;
    status)
        check_status
        ;;
    *)
        echo "可用命令: start, stop, restart, status"
        exit 1
        ;;
esac
exit $?
```


### openvpn

```bash
#!/bin/bash

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

SERVICE_NAME="openvpn"

#PID_FILE="/var/run/${SERVICE_NAME}.pid"
LOG_FILE="/var/log/${SERVICE_NAME}.log"

if [[ ! "$EUID" -eq 0 ]]; then
  echo -e "${YELLOW} 请使用 sudo 提权${NC}"
  exit 1
fi

# 函数：通过ps -ef查找进程PID
find_pid() {
    # 使用ps -ef查找进程，排除grep进程本身
    local pid=$(ps -ef|grep 'openvpn.conf' | grep -v grep |awk '{print $2}')
    echo $pid
}

# 函数：检查服务状态
check_status() {
    local pid=$(find_pid)
    if [ -n "$pid" ]; then
        # 检查进程是否真的存在
        if kill -0 $pid 2>/dev/null; then
            echo -e "${GREEN}服务 ${SERVICE_NAME} 正在运行 (PID: $pid)${NC}"
        #    # 显示详细进程信息
        #    echo "进程信息:"
        #    ps -p $pid -o pid,ppid,user,%cpu,%mem,cmd --no-headers
        #
        #    # 检查内存使用
        #    local mem_usage=$(ps -p $pid -o %mem --no-headers | awk '{print $1}')
        #    echo "内存使用: ${mem_usage}%"
        #
            return 0
        else
            echo -e "${YELLOW}找到PID但进程不存在，可能已异常退出${NC}"
            return 1
        fi
    else
        echo -e "${RED}服务 ${SERVICE_NAME} 未运行${NC}"
        return 1
    fi
}

# 函数：启动服务
start_service() {
    echo -e "${BLUE}正在启动 ${SERVICE_NAME}...${NC}"
    # 检查是否已在运行
    if check_status > /dev/null 2>&1; then
        echo -e "${YELLOW}服务 ${SERVICE_NAME} 已在运行中${NC}"
        return 0
    fi

    # 这里需要根据具体服务修改启动命令
    /opt/homebrew/sbin/openvpn --daemon --cd /opt/homebrew/etc/openvpn --config openvpn.conf --log-append ${LOG_FILE}

    # 等待进程启动
    sleep 2
    # 检查启动结果
    if check_status > /dev/null 2>&1; then
        local pid=$(find_pid)
        echo $pid > "$PID_FILE"
        echo -e "${GREEN}服务 ${SERVICE_NAME} 启动成功 (PID: $pid)${NC}"
        return 0
    else
        echo -e "${RED}服务 ${SERVICE_NAME} 启动失败${NC}"
        return 1
    fi
}

# 函数：停止服务
stop_service() {
    echo -e "${BLUE}正在停止 ${SERVICE_NAME}...${NC}"
    local pid=$(find_pid)

    if [ -z "$pid" ]; then
        echo -e "${YELLOW}服务 ${SERVICE_NAME} 未在运行${NC}"
        return 0
    fi

    # 先尝试优雅停止
    echo "尝试优雅停止..."
    kill -TERM $pid 2>/dev/null

    # 等待最多10秒
    local wait_time=0
    while [ $wait_time -lt 10 ]; do
        if ! kill -0 $pid 2>/dev/null; then
            echo -e "${GREEN}服务 ${SERVICE_NAME} 已优雅停止${NC}"
            rm -f "$PID_FILE"
            return 0
        fi
        sleep 1
        ((wait_time++))
    done

    # 强制停止
    echo "强制停止..."
    kill -KILL $pid 2>/dev/null
    sleep 1
    if ! kill -0 $pid 2>/dev/null; then
        echo -e "${GREEN}服务 ${SERVICE_NAME} 已强制停止${NC}"
        rm -f "$PID_FILE"
        return 0
    else
        echo -e "${RED}无法停止服务 ${SERVICE_NAME}${NC}"
        return 1
    fi
}

# 函数：重启服务
restart_service() {
    echo -e "${BLUE}正在重启 ${SERVICE_NAME}...${NC}"
    stop_service
    sleep 2
    start_service

}

# 根据命令执行相应操作
case $1 in
    start)
        start_service
        ;;
    stop)
        stop_service
        ;;
    restart)
        restart_service
        ;;
    status)
        check_status
        ;;
    *)
        echo "可用命令: start, stop, restart, status"
        exit 1
        ;;
esac
exit $?
```