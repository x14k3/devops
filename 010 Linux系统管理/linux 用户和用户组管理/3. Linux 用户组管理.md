# 3. Linux 用户组管理

‍

# groupadd命令

添加用户组的命令是 groupadd，命令格式如下:

```bash
[root@localhost ~]# groupadd [选项] 组名
```

选项： *  -g GID：指定组 ID；

* -r：创建系统群组。

使用 groupadd 命令创建新群组非常简单，例如：

```bash
[root@localhost ~]# groupadd group1
#添加group1组
[root@localhost ~]# grep "group1" /etc/group
/etc/group:group1:x:502:
/etc/gshadow:group1:!::
```

# groupdel命令

groupdel 命令用于删除用户组（群组），此命令基本格式为：

```bash
[root@localhost ~]#groupdel 组名
```

通过前面的学习不难猜测出，使用 groupdel 命令删除群组，其实就是删除 /etc/gourp 文件和 /etc/gshadow 文件中有关目标群组的数据信息。

例如，删除前面章节中用 groupadd 命令创建的群组 group1，执行命令如下：

```bash
[root@localhost ~]#grep "group1" /etc/group /etc/gshadow
/etc/group:group1:x:505:
/etc/gshadow:group1:!::
[root@localhost ~]#groupdel group1
[root@localhost ~]#grep "group1" /etc/group /etc/gshadow
[root@localhost ~]#
```

注意，不能使用 groupdel 命令随意删除群组。此命令仅适用于删除那些 "不是任何用户初始组" 的群组，换句话说，如果有群组还是某用户的初始群组，则无法使用 groupdel 命令成功删除。例如：

```bash
[root@localhost ~]# useradd temp
#运行如下命令，可以看到 temp 用户建立的同时，还创建了 temp 群组，且将其作为 temp用户的初始组（组ID都是 505）
[root@localhost ~]# grep "temp" /etc/passwd /etc/group /etc/gshadow
/etc/passwd:temp:x:505:505::/home/temp:/bin/bash
/etc/group:temp:x:505:
/etc/gshadow:temp:!::
#下面尝试删除 temp 群组
[root@localhost ~]# groupdel temp
groupdel:cannot remove the primary group of user 'temp'
```

可以看到，groupdel 命令删除 temp 群组失败，且提示“不能删除 temp 用户的初始组”。如果一定要删除 temp 群组，要么修改 temp 用户的 GID，也就是将其初始组改为其他群组，要么先删除 temp 用户。

切记，虽然我们已经学了如何手动删除群组数据，但胡乱地删除群组可能会给其他用户造成不小的麻烦，因此更改文件数据要格外慎重。

# groupmod命令

groupmod 命令用于修改用户组的相关信息，命令格式如下：

```bash
[root@localhost ~]# groupmod [选现] 组名
```

选项： *  -g GID：修改组 ID；

* -n 新组名：修改组名；

例子

```bash
[root@localhost ~]# groupmod -n testgrp group1
#把组名group1修改为testgrp
[root@localhost ~]# grep "testgrp" /etc/group
testgrp:x:502:
#注意GID还是502，但是组名已经改变
```

不过大家还是要注意，用户名不要随意修改，组名和 GID 也不要随意修改，因为非常容易导致管理员逻辑混乱。如果非要修改用户名或组名，则建议大家先删除旧的，再建立新的。

‍

# groupmems命令

​`groupmems`​ 命令允许用户管理他/她自己的组成员列表，而不需要超级用户权限。`groupmems`​ 实用程序适用于将其用户配置为以他们自己的名义主组（即来宾/来宾）的系统。

只有作为管理员的超级用户可以使用 `groupmems`​ 来更改其他组的成员资格。

```nginx
groupmems -a user_name | -d 用户名 | [-g 用户组名] | -l | -p
-a, --add user_name # 将用户添加到组成员列表。如果 /etc/gshadow 文件存在，并且该组在 /etc/gshadow 文件中没有条目，则将创建一个新条目。

-d, --delete user_name
# 从组成员列表中删除用户。
# 如果 /etc/gshadow 文件存在，用户将从组的成员和管理员列表中删除。
# 如果 /etc/gshadow 文件存在，并且该组在 /etc/gshadow 文件中没有条目，则将创建一个新条目。

-g, --group group_name # 超级用户可以指定要修改的组成员列表。
-l, --list             # 列出组成员列表。
-p, --purge            # 从组成员列表中清除所有用户。
# 如果 /etc/gshadow 文件存在，并且该组在 /etc/gshadow 文件中没有条目，则将创建一个新条目。

```

### 配置

​`/etc/login.defs`​ 中的以下配置变量会更改此工具的行为：

```shell
MAX_MEMBERS_PER_GROUP (number)
```

<pre class="language-shell"><div data-code="MAX_MEMBERS_PER_GROUP (number)
" class="copied"></div></pre>

每个组条目的最大成员数。 当达到最大值时，在 `/etc/group`​ 中启动一个新的组条目（行）（具有相同的名称、相同的密码和相同的 GID）。

默认值为 0，表示组中的成员数量没有限制。

此功能（拆分组）允许限制组文件中的行长度。 这有助于确保 NIS 组的行不超过 1024 个字符。

如果你需要强制执行这样的限制，你可以使用 25。

注意：并非所有工具都支持拆分组（即使在 Shadow 工具包中）。 除非你真的需要它，否则你不应该使用这个变量。

### 例子

groupmems 可执行文件应该在模式 2770 中作为用户 root 和组组。 系统管理员可以将用户添加到组中，以允许或禁止他们使用 groupmems 实用程序来管理他们自己的组成员列表。

```shell
groupadd -r groups
chmod 2770 groupmems

chown root.groups groupmems
groupmems -g groups -a gk4
```

<pre class="language-shell"><div data-code="groupadd -r groups
chmod 2770 groupmems

chown root.groups groupmems
groupmems -g groups -a gk4
" class="copied"></div></pre>

让我们创建一个新用户和一个新组并验证结果：

```shell
useradd student
passwd student
groupadd staff
```

<pre class="language-shell"><div data-code="useradd student
passwd student
groupadd staff
" class="copied"></div></pre>

使用户 student 成为组人员的成员：

```shell
groupmems -g staff -a student
groupmems -g staff -l 
```

<pre class="language-shell"><div data-code="groupmems -g staff -a student
groupmems -g staff -l 
" class="copied"></div></pre>

将用户添加到组：

```shell
groupmems -a mike -g SUPPORT
groupmems --add mike -g SUPPORT 
```

<pre class="language-shell"><div data-code="groupmems -a mike -g SUPPORT
groupmems --add mike -g SUPPORT 
" class="copied"></div></pre>

从组中删除/移除用户：

```shell
groupmems -d mike SUPPORT -g SUPPORT
groupmems --delete mike SUPPORT -g SUPPORT
```

<pre class="language-shell"><div data-code="groupmems -d mike SUPPORT -g SUPPORT
groupmems --delete mike SUPPORT -g SUPPORT
" class="copied"></div></pre>

更改组名称：

```shell
groupmems -g SUPPORT
```

<pre class="language-shell"><div data-code="groupmems -g SUPPORT
" class="copied"></div></pre>

从组中删除用户：

```shell
groupmems -p -g SUPPORT
groupmems --purge -g SUPPORT
```

<pre class="language-shell"><div data-code="groupmems -p -g SUPPORT
groupmems --purge -g SUPPORT
" class="copied"></div></pre>

要列出组的成员：

```shell
groupmems -l -g SUPPORT
groupmems --list -g SUPPORT
```

# newgrp命令

我们知道，每个用户可以属于一个初始组（用户是这个组的初始用户），也可以属于多个附加组（用户是这个组的附加用户）。既然用户可以属于这么多用户组，那么用户在创建文件后，默认生效的组身份是哪个呢？

当然是初始用户组的组身份生效，因为初始组是用户一旦登陆就获得的组身份。也就是说，用户的有效组默认是初始组，因此所创建文件的属组是用户的初始组。那么，既然用户属于多个用户组，能不能改变用户的初始组呢？使用命令 newgrp 就可以。

newgrp 命令可以从用户的附加组中选择一个群组，作为用户新的初始组。此命令的基本格式如下：

```bash
[root@localhost ~]# newgrp 组名
```

下面，我们通过一个实例，讲解此命令的具体用法和功能：

1. 首先，建立 3 个用户组 group1、group2 和 group3，命令如下：

    ```bash
    [root@localhost ~]# groupadd group1
    [root@localhost ~]# groupadd group2
    [root@localhost ~]# groupadd group3

    ```

2. 创建一个用户 user1，同时指定 user1 的初始组为 group1，附加组为 group2 和 group3，执行命令如下：

    ```bash
    [root@localhost ~]# useradd -g group1 -G group2,group3 user1
    #由于指定了初始组，因此不会在创建 user1 默认群组
    [root@localhost ~]# more /etc/group | grep user1
    group2:x:501:user1
    group3:x:502:user1

    ```

3. 对用户 user1 设置密码，执行命令如下：

    ```bash
    [root@localhost ~]# passwd user1
    Changing password for user user1.
    New password:
    Retype new password:
    passwd: all authentication tokens updated successfully.
    ```

4. 切换至 user1 用户，通过 newgrp 切换用户组进行下列操作，读者可从中体会出 newgrp 命令的作用。

    ```bash
    #切换至 user1 用户
    [root@localhost ~]# su - user1
    [root@localhost ~]# whoami
    user1
    #使用 newgrp 命令一边切换 user1 的初始组，一边创建文件
    [root@localhost ~]# mkdir user1_doc
    [root@localhost ~]# newgrp group2
    [root@localhost ~]# mkdir user2_doc
    [root@localhost ~]# newgrp group3
    [root@localhost ~]# mkdir user3_doc
    #查看各文件的详细信息
    [root@localhost ~]# ll
    total 12
    drwxr-xr-x 2 user1 group1 4096 Oct 24 01:18 user1_doc
    drwxr-xr-x 2 user1 group2 4096 Oct 24 01:18 user2_doc
    drwxr-xr-x 2 user1 group3 4096 Oct 24 01:19 user3_doc
    ```

可以看到，通过使用 newgrp 命令切换用户的初始组，所创建的文件各自属于不同的群组，这就是 newgrp 所发挥的作用，即通过切换附加组成为新的初始组，从而让用户获得使用各个附加组的权限。

## newgrp命令的底层实现

其实，newgrp 命令每一次切换用户的初始组，该用户都会以另外一个 shell（新进程，也可以说是子进程）登陆，只不过在新 shell 上登陆的该用户，其初始组改变了而已。

**以上实例中，通过添加 shell 内置命令 &quot;echo $$&quot; 就可以发现，每次使用 newgrp 命令，都会切换到一个新的进程。**

可以看到，每一次使用 newgrp 切换用户的初始组，用户都会切换到一个新的子 shell 中，如图 1 中，user1 用户的初始组从最初的 group1，切换成了 group2，再切换成 group3。

‍

‍

当然，如果你想回到原本的环境，需要通过 exit 命令不断回退到当前进程的父进程，最终才能回到初始组为 group1 时的 user1 运行的 shell 中。
