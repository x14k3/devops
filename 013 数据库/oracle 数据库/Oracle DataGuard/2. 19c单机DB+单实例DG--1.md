# 2. 19c单机DB+单实例DG--1

## 1. 环境准备

### 1.1 关闭防火墙和SELinux

```bash
systemctl stop firewalld;
systemctl disable firewalld
sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config
setenforce 0
```

### 1.2 修改hosts

​`vim /etc/hosts`​

```txt
10.0.0.23  primary
10.0.0.24  standby
```

### 1.3 安装Orcle19c

db1部署数据库软件和实例，db2只部署数据库软件。

|操作系统|主机名|IP地址|数据库版本|实例名|DB_NAME|DB_UNIQUE_NAME|
| ------------| ---------| -----------| ------------| --------| ---------| ----------------|
|CentOS 7.9|primary|10.0.0.23|Oracle 19c|orcl|orcl|primary|
|CentOS 7.9|standby|10.0.0.24|Oracle 19c|orcl|orcl|standby|

## 2. primary主库配置

### 2.1 主库启动force logging和日志归档

```sql
sqlplus / as sysdba

-- 打开强制写入日志
alter database force logging;
select force_logging from v$database;

-- 设置归档
-- 查看数据库是否运行在归档模式
archive log list;
alter system set log_archive_config='DG_CONFIG=(orcl,orcldg)' scope=both sid='*';
alter system set log_archive_dest_1='LOCATION=/data/arch VALID_FOR=(ALL_LOGFILES,ALL_ROLES) DB_UNIQUE_NAME=orcl' scope=spfile;
-- SERVICE=orcldg tns中设置的网络名
alter system set log_archive_dest_2='SERVICE=orcldg LGWR SYNC AFFIRM VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) DB_UNIQUE_NAME=orcldg' scope=both sid='*';
shutdown immediate;
startup mount;
alter database archivelog;
-- 开启数据库
alter database open;
```

**LOGGING：** 当创建一个数据库对象时将记录日志信息到联机重做日志文件。LOGGING实际上是对象的一个属性，用来表示在创建对象时是否记录REDO日志，包括在做DML时是否记录REDO日志。

**FORCE LOGGING：** 简言之，强制记录日志，即对数据库中的所有操作都产生日志信息，并将该信息写入到联机重做日志文件。

**NOLOGGING：** 正好与LOGGING、FORCE LOGGING 相反，尽可能的记录最少日志信息到联机日志文件。一般表上不建议使用NOLOGGING,在创建索引或做大量数据导入时，可以使用NOLOGGING

### 2.2 主库添加 STANDBY 日志文件

```sql
# 查看当前redo日志
select group#,type,member from v$logfile;
# 这里添加4组redo日志
alter database add standby logfile group 4 ('/data/oradata/ORCL/redo04.log') size 200M;
alter database add standby logfile group 5 ('/data/oradata/ORCL/redo05.log') size 200M;
alter database add standby logfile group 6 ('/data/oradata/ORCL/redo06.log') size 200M;
alter database add standby logfile group 7 ('/data/oradata/ORCL/redo07.log') size 200M;
```

### 2.3 分别在主备库配置监听文件并启动

```txt
SID_LIST_LISTENER =
  (SID_LIST =
    (SID_DESC =
      (GLOBAL_DBNAME = orcl)
      (ORACLE_HOME = /u01/app/oracle/product/11.9.0/db_1)
      (SID_NAME = orcl)
    )
  )
LISTENER =
  (DESCRIPTION_LIST =
    (DESCRIPTION =
      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))
      (ADDRESS = (PROTOCOL = TCP)(HOST = 10.0.0.23)(PORT = 1521))
    )
  )
ADR_BASE_LISTENER = /u01/app/oracle
```

重启监听

```bash
[oracle@primary admin]$ lsnrctl reload
LSNRCTL for Linux: Version 11.2.0.4.0 - Production on 11-JAN-2019 23:53:24
Copyright (c) 1991, 2013, Oracle.  All rights reserved.
Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=IPC)(KEY=EXTPROC1521)))
The command completed successfully
```

### 2.4分别在主备库上配置tnsname.ora

```txt
primary =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 10.0.0.23)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = orcl)
    )
 )
standby =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 10.0.0.24)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = orcl)
      (UR = A)
    )
  )
```

### 2.5 验证监听和TNS配置

在主库上验证：

```bash
tnsping orcl
tnsping orcldg
sqlplus sys/Ninestar2022@orcl as sysdba
sqlplus sys/Ninestar2022@orcldg as sysdba

```

在备库上验证：

```bash
tnsping orcl
tnsping orcldg
sqlplus sys/Ninestar2022@orcl as sysdba
sqlplus sys/Ninestar2022@orcldg as sysdba
```

### 2.6 在主库上创建pfile文件并修改pfile内容

```bash
SQL> create pfile from spfile;
# pfile文件添加内容
vim initorcl.ora 
--------------------------------------------------------------
*.db_unique_name='primary'
*.log_archive_config='dg_config=(primary,standby)'
*.log_archive_dest_1='location=/data/arch valid_for=(all_logfiles,all_roles) db_unique_name=primary'
*.log_archive_dest_2='service=standby lgwr affirm sync valid_for=(online_logfiles,primary_role) db_unique_name=standby'
*.log_archive_dest_state_1=enabl
*.log_archive_dest_state_2=enable
*.standby_file_management='auto'
*.fal_server='standby'
*.log_file_name_convert='data/oradata/ORCL/','/data/oradata/ORCL/'
*.db_file_name_convert='data/oradata/ORCL/','/data/oradata/ORCL/'
--------------------------------------------------------------
# 使用新的参数重启数据库
SQL> create spfile from pfile;
File created.
SQL> startup
ORACLE instance started.
Total System Global Area  972898304 bytes
Fixed Size                  2259160 bytes
Variable Size             616564520 bytes
Database Buffers          348127232 bytes
Redo Buffers                5947392 bytes
Database mounted.
Database opened.
```

==**参数解析**==

```txt
log_archive_config：
	用于控制发送归档日志到远程位置、接收远程归档日志， 并指定Data Guard配置的惟一数据库名
	当主库与备库的db_unique_name相同时,log_archive_config就不需要配置了，直接将其置空。

LOG_ARCHIVE_DEST_1：
	设置一个从归档路径。所有的路径必须是本地的。VALID_FOR属性用来控制日志传输
	-  online_logfile: 表示归档联机重做日志
    -  standby_logfile:表示归档备用数据库的重做日志/接受来自主库的重做日志
    -  all_logfiles: online_logfile && standby_logfile
    -  primary_role: 仅当数据库角色为主库时候生效
    -  standby_role: 仅当数据库角色为备库时候生效
    -  all_role: 任意角色均生效

LOG_ARCHIVE_DEST_2：
	设置远程归档到standby端，同时设置Rode归档进程LGWR、网络传输模式SYNC、控制日志传输服务是异步还是同步AFFIRM

FAL_CLIENT & FAL_SERVER：
	解决归档间隙（GAP），当备库不能接受到一个或多个主库的归档日志文件时候，就发生了GAP
	fal_client会自动向fal_server传输间隙的存档日志，自动解决归档GAP


STANDBY_FILE_MANAGEMENT：
	-  AUTO：在主数据库上创建的任何新数据文件都会自动在物理备用数据库上创建。
	-  MANUAL：在将新数据文件添加到主数据库后，必须手动将其从主数据库复制到物理备用数据库。

db_file_name_convert & log_file_name_convert：
	当用主库的备份来恢复从库时，来完成转换dataguard的主库和从库数据文件和联机日志保存路径不同的问题

```

### 2.7 将主库的口令文件和参数文件复制到备库中

```bash
scp orapworcl oracle@standby:$ORACLE_HOME/dbs
scp initorcl.ora oracle@standby:$ORACLE_HOME/dbs
```

## 3. standby从库配置

### 3.1 修改备库参数文件

```sql
*.db_unique_name='standby'
*.log_archive_config='dg_config=(primary,standby)'
*.log_archive_dest_1='location=/data/archive/ valid_for=(all_logfiles,all_roles) db_unique_name=standby'
*.log_archive_dest_2='service=standby lgwr affirm sync valid_for=(online_logfiles,primary_role)
db_unique_name=primary'
*.log_archive_dest_state_1=enable
*.log_archive_dest_state_2=enable
*.standby_file_management='auto'
*.fal_server='primary'
*.log_file_name_convert='/data/oradata/ORCL/','/data/oradata/ORCL/'
*.db_file_name_convert='/data/oradata/ORCL/','/data/oradata/ORCL/'
```

创建所需目录  
​`mkdir -p /data/u01/app/oracle/admin/orcl/adump /data/arch /data/oradata/ORCL`​  
​`chown -R oracle:oinstall /data/u01/app/oracle/admin/orcl/adump /data/arch/ /data/oradata/ORCL`​

### 3.2 通过pfile文件生成spfile并将standby库启动到nomount状态

```bash
SQL> create spfile from pfile;
File created.
SQL> startup nomount;
ORACLE instance started.
Total System Global Area  972898304 bytes
Fixed Size                  2259160 bytes
Variable Size             616564520 bytes
Database Buffers          348127232 bytes
Redo Buffers                5947392 bytes
```

重启监听  
​`lsnrctl restart`​

连接standby常见错误：

```
ERROR:
ORA-12528: TNS:listener: all appropriate instances are blocking new connections
```

举个粟子，使用duplicate 复制数据库时，目标实例只启动到nomount状态。此时，监听 中对应实例的状态就是“BLOCKED”. 解决方法是在TSN配置添加特殊标记(UR = A),示例 如下：

```bash
primary =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 10.0.0.23)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = orcl)
    )
 )
standby =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 10.0.0.24)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = orcl)
      (UR = A)
    )
  )

```

### 3.3 在主库上开始进行duplicate achive

```bash
[oracle@primary ~]$ rman target / auxiliary sys/oracle@standby
Recovery Manager: Release 11.2.0.4.0 - Production on Sun Jan 13 00:01:44 2019
Copyright (c) 1982, 2011, Oracle and/or its affiliates.  All rights reserved.
connected to target database: ORCL (DBID=1524649093)
connected to auxiliary database: ORCL (not mounted)

RMAN> duplicate target database for standby from active database nofilenamecheck dorecover;

# 如果⽬录结构⼀致需要nofilenamecheck参数 
```

### 3.4 打开备库并启动apply

```sql
-- 打开备库
sqlplus / as sysdba
select open_mode from v$database;
alter database open; 
--方式一：开启实时同步 
alter database recover managed standby database using current logfile disconnect from session; 
--方式二：开启同步（日志切换时才同步） 
alter database recover managed standby database disconnect from session;
-- 取消同步
alter database recover managed standby database cancel;
```

## 4. DataGuard 验证

```sql
-- 状态查看（主备都可查看）
select open_mode,      --数据库打开模式，如果实时同步，则为：read only with apply，异步同步则为：read only
       database_role,       --数据库角色，是主库还是备库
       protection_mode,     --保护模式
       protection_level     --保护级别
from   v$database;
--------------------------------------------------------------------------
OPEN_MODE            DATABASE_ROLE    PROTECTION_MODE      PROTECTION_LEVEL
-------------------- ---------------- -------------------- --------------------
-- 主库：READ WRITE           PRIMARY          MAXIMUM PERFORMANCE  MAXIMUM PERFORMANCE
-- 备库：READ ONLY WITH APPLY PHYSICAL STANDBY MAXIMUM PERFORMANCE  MAXIMUM PERFORMANCE
```

## 5. 其他配置

### 1. 保护模式切换

```sql
-- 查询保护模式，默认最⼤性能模式（主库执行）
select protection_mode,protection_level from v$database;
-- 1.先切换最⼤可⽤模式（主库执行）
alter database set standby to maximize availability;
-- 若从最大性能模式直接切换到最大保护模式，需要先把备库重启到到mount，再把主库重启到到mount
shutdown immediate;
alter database mount;
-- 但是可⽤先切换到最⼤可⽤模式，再切换 到最⼤保护模式。
-- 如果直接从最⼤性能模式切换会报错。切换最⼤保护模式需要LGWR，SYNC⽀持。
-- 如果已配置lgwr sync就不需要执⾏这个命令
-- alter system set log_archive_dest_2='service=orcldg LGWR SYNC AFFIRM valid_for= (all_logfiles,primary_role) db_unique_name=orcldg;
-- 2.在切换⾄最⼤保护模式（主库执行）
alter database set standby database to maximize protection;
alter database open;
-- 注意：切换最⼤保护模式后，备库不让关闭的。如果你shutdown abort 强制关闭，则主库⽆法做操作 （DML,DDL）
```

### 2. 主备切换

DG的主备角色转换分为：Switchover和Failover。Switchover适用于某些场合，需要将备库转为主库，Failover则是在主库故障无法使用情况下，将备库提升为主库。

* switchover是有计划的，正常的切换，不会破坏数据库DG关系
* failover是非计划的，破坏性的切换，切换之后要重建DG

#### 2.1 修改server_name（sid不一样）

当切换至备库是使连接信息与主库⼀致，在备库进行如下操作

```sql
alter system set service_names='orcl';
```

​`cd $ORACLE_HOME/network/admin/ ; vim listener.ora`​

```txt
# listener.ora Network Configuration File: /data/u01/app/oracle/product/19.3.0/db_1network/admin/listener.ora
# Generated by Oracle configuration tools.

SID_LIST_LISTENER=
  (SID_LIST=
    (SID_DESC=
      (GLOBAL_DBNAME = orcl)   # 只修改GLOBAL_DBNAME
      (SID_NAME = orcldg)
      (ORACLE_HOME = /data/u01/app/oracle/product/19.3.0/db_1)
    )
  )

LISTENER=
  (DESCRIPTION=
    (ADDRESS_LIST=
      (ADDRESS=(PROTOCOL = tcp)(HOST = 10.0.0.24)(PORT = 1521))
    )
  )

ADR_BASE_LISTENER = /data/u01/app/oracle
```

​`cd $ORACLE_HOME/network/admin/ ; vim tnsnames.ora`​

```txt
orcl =
  (DESCRIPTION =
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = TCP)(HOST = 10.0.0.23)(PORT = 1521))
    )
    (CONNECT_DATA =
      (SERVICE_NAME = orcl)
      (SERVER = DEDICATED)
    )
  )


orcldg =
  (DESCRIPTION =
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = TCP)(HOST = 10.0.0.24)(PORT = 1521))
    )
    (CONNECT_DATA =
      (SERVICE_NAME = orcl)   # 只修改SERVICE_NAME
      (SERVER = DEDICATED)
    )
  )
```

#### 2.2 Switchover

大致步骤为主库先转换为备库，在此阶段可能看到原先的主备皆为备库状态，然后再将原备库设置为主库。  

* **主库操作**

  ```sql
  -- 1. 检查是否已经添加standby redo log；standby redo log数量应等于redo数量 +1 
  select * from v$standby_log

  -- 2. 检查主库状态
  -- SWITCHOVER_STATUS转换状态：to standby和session active（有会话连接），这两种状态可以转换
  select NAME,DATABASE_ROLE,SWITCHOVER_STATUS from v$database;

  -- 3. 检查主备之间是否有GAP -- dest_id:1主库 2备库
  select STATUS, GAP_STATUS from v$archive_dest_status t where DEST_ID = 2;

  -- 4. swithover切换（主库执行完毕实例会自动关闭）
  alter database commit to switchover to physical standby;
  -- 当有会话连接的情况下，执行上面命令会失败，需要用这一条
  -- alter database commit to switchover to physical standby with session shutdown;

  -- 5. 启动数据库
  startup;
  -- 检查当前数据库状态，此时应看到已经是read only，且是PHYSICAL STANDBY状态
  select NAME,DATABASE_ROLE,SWITCHOVER_STATUS from v$database;
  -- 开启实时应用
  alter database recover managed standby database using current logfile disconnect;
  ```

* **备库操作**

  ```sql
  -- 1. 检查状态，SWITCHOVER_STATUS是to primary或session active就可以切换
  select NAME,DATABASE_ROLE,SWITCHOVER_STATUS from v$database;

  -- 2. 执行切换（执行后为mounted状态）
  alter database commit to switchover to primary with session shutdown;

  -- 3. 启动
  alter database open;
  -- 再次查询 SWITCHOVER_STATUS是to standby
  select NAME,DATABASE_ROLE,SWITCHOVER_STATUS from v$database;

  ```

* ！注意事项

  * 生产环境切换时间会长，考虑执行alter system flush buffer_cache，将内存数据刷到磁盘
  * 写检查点alter system checkpoint
  * 考虑先关闭应用，无用户连接可以减少切换的时间

#### 2.3 Failover

如果IDC机房⽹络出现问题、或者主机房服务器出现故障短时间内⽆法恢复，需要使⽤备库接管为 主库提供服务。备库如果接管为主库后，⽆法再回到备库（需要重新部署）。  
*模拟先把主备数据库的Listener停⽌，或者停⽌备库接收⽇志。*

* **备库操作**

  ```sql
  -- 1. 查询是否有⽇志gap,若存在gap则执行2-6，若无gap则执行6
  select thread#,low_sequence#,high_sequence# from v$archive_gap;

  -- 2. 查询归档⽇志应⽤情况，根据归档号那些归档没有传输过来。
  select sequence#,name,applied from v$archived_log order by sequence#;
  -- 拷⻉redo ⽇志和归档⽇志到备库,如果有多个⽇志成员，每组拷⻉⼀个成员即可，
  -- 归档⽇志可以进 ⾏归档号进⾏对⽐或者查询为应⽤的归档⽇志。

  -- 3. 查询未应⽤的归档⽇志
  select sequence#,name,applied from v$archived_log;

  -- 4. 通过以下命令进⾏注册
  alter database register physical logfile '/data/arch_orcldg/1_762_946467761.dbf';
  alter database recover managed standby database disconnect from session;
  ...
  ...
  ...

  -- 5. 再进⾏实例恢复，填⼊主库的redo⽇志
  recover standby database;

  -- 6. 切换为主库
  select database_role from v$database;
  alter database activate physical standby database;
  alter database open;
  ```

  以上步骤将备库切换为新主库，接下来恢复DataGuard高可用模式，搭建新备库。如果条件满⾜的情况 下建议使⽤duplicate⽅式恢复主备模式。或者使⽤RMAN备份集来进⾏恢复。  
  参考上面的步骤搭建新备库 [[#Data Guard 部署]]

#### 2.4 使⽤快照技术激活备库

测试场景 备库需要作为测试环境使⽤时 DG是正常同步的情况下进⾏ 在切换成snapshot 测试场景，备库需要作为测试环境使⽤时。DG是正常同步的情况下进⾏。在切换成snapshot standby 时，主备数据库⽇志还是⾃动传输的，不会照成数据丢失。

* **备库操作**

  ```sql
  -- 1. 切换⾄snapshot standby database
  startup mount;
  alter database convert to snapshot standby;
  -- ORA-38786: Recovery area is not enabled. #需要配置db_recover参数
  -- 配置快速恢复⼤⼩和路径
  -- alter system set db_recovery_file_dest_size=4G;
  -- alter system set db_recovery_file_dest='/data/arch_orcldg';
  -- alter database convert to snapshot standby;

  -- 2. 查询数据库⻆⾊和打开模式
  select database_role,open_mode from v$database;

  -- 3. 启动
  alter database open;
  select database_role,open_mode from v$database;

  -- 此时备库可以正常提交数据，同时主库也是可以正常读写
  ```

* **还原为physical standby（备库操作）**

  ```sql
  -- 1. 启动到mount阶段进⾏切换操作
  shutdown immediate;
  startup mount;
  alter database convert to physical standby;
  startup mount force;
  select database_role,open_mode from v$database;
  alter database open;
  select database_role,open_mode from v$database;
  alter database recover managed standby database using current logfile disconnect from session;
  select database_role,open_mode from v$database;
  ```

#### 2.5 DG Broker

DG Broker是一个分布式管理框架，可自动且集中创建、维护和监控 DG。

#### 2.6 DG Broker

### 3.密码修改

在Oracle11g通过alter user sys identified by xxx 修改sys用户密码时，不会自动更新备库的密码文件。Oracle Dataguard环境的日志传输安全机制依靠Oracle生产库的密码文件，

```sql
-- 在主库执行
alter system archive log current ;

-- 关闭备库
shutdown immediate;

-- 在主库执行
alter user sys identified by newpasswd;

-- 将主库密码文件修改后复制到备库相应目录

-- 启动备库
startup mount
alter database open; 
alter database recover managed standby database using current logfile disconnect from session;

```

### 4.主备日志清理

* 主库

  ```bash
  # 主库RMAN 配置

  CONFIGURE RETENTION POLICY TO RECOVERY WINDOW OF 7 DAYS;
  # 归档日志只有在备库应用后才可以删除！
  CONFIGURE ARCHIVELOG DELETION POLICY TO APPLIED ON STANDBY;
  ```

* 备库

  ```bash
  #!/bin/bash
  source /home/oracle/.bash_profile
  rman target / <<ORMF
  run {
  crosscheck archivelog all;
  delete noprompt archivelog until time 'sysdate-7';
  }
  ORMF
  ```
