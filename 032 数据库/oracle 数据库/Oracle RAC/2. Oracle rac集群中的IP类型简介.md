# 2. Oracle rac集群中的IP类型简介

在Oracle RAC中，有Public IP、Private IP、Virtual IP、SCAN IP、GNS VIP及HAIP，这些IP支撑Oracle 数据库内部及外部的通信。

从Oracle 11g开始，安装RAC至少需要**7个IP地址**，两块网卡（一块公网网卡，一块私网网卡），**Public IP、Virtual IP、SCAN IP都在同一个网段，使用的是公网网卡**，private在另一个网段，使用的是私网网卡。

## **Public IP**

Oracle通过Public IP对外提供网络服务。如果RAC中Public IP所在的网卡设备故障，那么该节点将无法继续对外提供服务，所以，建议通过开启操作系统层面的多网卡绑定技术来实现IP Failover。

## **Private IP**

节点和节点之间的通信，主要为集群之间与数据库实例之间的通信使用。从11gR2开始推出HAIP技术提供私网的高可用性和负载均衡特性，之前版本通过服务器的双网卡绑定提供私网的可靠性。

## **Virtual IP**

VIP是Oracle 10g RAC的新特性，称为虚拟IP。VIP是在Public IP所在的网卡上由Oracle集群软件虚拟出来的一个IP，需要和Public IP设置在同一个子网网段中。Oracle集群软件安装之前只需定义好（/etc/hosts文件）即可，而无需事先配置。

在正常情况下，VIP和Public IP的功能是一模一样的。后台进程PMON对每个节点的VIP所在的监听器注册实例信息，本地监听器中会看到两个地址host，一个是Public IP，一个是VIP。

某个节点故障，则VIP移到好的节点上，但好节点的监听里找不到该VIP，应用程序会立刻发现问题，转而向其他VIP发送连接请求。但是用户还是可以知道整个RAC架构是由多少个节点组成，所以，Oracle 11g RAC中推出了SCAN IP的新概念，可以实现对用户连接的透明性，用户不再需要知道整个RAC架构中是由多少个节点组成的。

VIP的特点：

（1）VIP是通过VIPCA脚本创建的。

（2）VIP作为Nodeapps类型的CRS Resource注册到OCR中，并由CRS维护状态。

（3）VIP会绑定到节点的Public网卡上，故Public网卡有两个地址。

（4）当某个节点发生故障时，CRS会把故障节点的VIP转移到其它节点上。

（5）每个节点的LISTENER会同时监听Public网卡上的Public IP和VIP。

（6）客户端的tnsnames.ora一般会配置指向节点的VIP。

可以使用如下命令让节点1的VIP强制漂移到节点2上去：

```bash
crsctl relocate resource ora.raclhr-11gr2-n1.vip -n raclhr-11gR2-N2 -f
```

下命令针对Oracle 11g版本之前：

```javascript
crs_relocate ora.lhr-11gr2-rac1.vip -c lhr-11gR2-rac2 -f
```

‍

## **SCAN IP**

Oracle 11G R2 RAC增加了scan  ip功能，在11.2之前，client链接数据库的时候要用vip，假如你的cluster有4个节点，那么客户端的tnsnames.ora中就对应有四个主机vip的一个连接串，如果cluster增加了一个节点，那么对于每个连接数据库的客户端都需要修改这个tnsnames.ora。

引入了scan以后，就方便了客户端连接的一个接口，顾名思义 single client access name  ，简单客户端连接名，这是一个唯一的名称，在整个公司网络内部唯一，并且在DNS中可以解析为三个ip地址，客户端连接的时候只需要知道这个名称，并连接即可，  每个SCAN VIP对应一个scan listener，cluster内部的service在每个scan listener上都有注册，scan  listener接受客户端的请求，转发给对应的instance上的Local listener（VIP LISTENER），从而完成了整个客户端与服务器的连接过程

​![cfu9qbxqjw](assets/cfu9qbxqjw-20240201094723-o514lpc.jpeg)​

要使用SCAN IP来连接rac数据库，并且实现负载均衡的功能，那么需要在数据库中配置参数remote_listener：

```bash
alter system set remote_listener='raclhr-19c-scan:1521' sid='*';
```

其中，raclhr-19c-scan是集群的scan名称。

通过设置这个参数，任何数据库实例都会向SCAN监听器注册，主要用于注册远程数据库实例，所以SCAN监听器能够负载均衡地分发连接请求到节点本地监听器上，也就是连接到其本地节点上实例上。

scan监听器的监听状态如下：

```bash
[root@raclhr-19c-n1 ~]# lsnrctl status LISTENER_SCAN1

LSNRCTL for Linux: Version 19.0.0.0.0 - Production on 02-MAR-2021 15:06:21

Copyright (c) 1991, 2019, Oracle.  All rights reserved.

Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=IPC)(KEY=LISTENER_SCAN1)))
STATUS of the LISTENER
------------------------
Alias                     LISTENER_SCAN1
Version                   TNSLSNR for Linux: Version 19.0.0.0.0 - Production
Start Date                02-MAR-2021 09:54:36
Uptime                    0 days 5 hr. 11 min. 45 sec
Trace Level               off
Security                  ON: Local OS Authentication
SNMP                      OFF
Listener Parameter File   /u01/app/19.3.0/grid/network/admin/listener.ora
Listener Log File         /u01/app/grid/diag/tnslsnr/raclhr-19c-n1/listener_scan1/alert/log.xml
Listening Endpoints Summary...
  (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=LISTENER_SCAN1)))
  (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=192.168.59.56)(PORT=1521)))
Services Summary...
Service "86b637b62fdf7a65e053f706e80a27ca" has 2 instance(s).
  Instance "rac19c1", status READY, has 1 handler(s) for this service...
  Instance "rac19c2", status READY, has 1 handler(s) for this service...
Service "9188f464f9113646e053343ba8c0fe51" has 2 instance(s).
  Instance "rac19c1", status READY, has 1 handler(s) for this service...
  Instance "rac19c2", status READY, has 1 handler(s) for this service...
Service "pdblhr1" has 2 instance(s).
  Instance "rac19c1", status READY, has 1 handler(s) for this service...
  Instance "rac19c2", status READY, has 1 handler(s) for this service...
Service "rac19c" has 2 instance(s).
  Instance "rac19c1", status READY, has 1 handler(s) for this service...
  Instance "rac19c2", status READY, has 1 handler(s) for this service...
Service "rac19cXDB" has 2 instance(s).
  Instance "rac19c1", status READY, has 1 handler(s) for this service...
  Instance "rac19c2", status READY, has 1 handler(s) for this service...
Service "rac19c_CFG" has 2 instance(s).
  Instance "rac19c1", status READY, has 1 handler(s) for this service...
  Instance "rac19c2", status READY, has 1 handler(s) for this service...
The command completed successfully

```

接下来做负载均衡测试：

```bash
[root@raclhr-19c-n2 ~]# more lhr_load_banlance.sh 
#!/bin/bash  
for i in {1..100}
do
echo $i
sqlplus -S "sys/lhr@192.168.59.56/rac19c as sysdba" <<EOF
select instance_name from v\$instance;
EOF
done
exit 0
EOF
[root@raclhr-19c-n2 ~]# chmod +x lhr_load_banlance.sh
[root@raclhr-19c-n2 ~]# ./lhr_load_banlance.sh > a.txt
[root@raclhr-19c-n2 ~]# more a.txt | grep rac19c1 | wc -l
42
[root@raclhr-19c-n2 ~]# more a.txt | grep rac19c2 | wc -l 
58
```

可以看到，通过SCAN IP基本上是负载均衡的连接到rac的2个节点上。

## **GNS VIP**

GNS VIP是Oracle 11g RAC新特性。在传统RAC架构中，Public IP、Private IP、Virtual IP、SCAN  IP都是预先配好的。如果开启了GNS服务只需要预先配置Public IP、Private IP即可，Virtual IP、SCAN  IP都是由GNS服务从**DHCP**服务器动态获取的。配置GNS服务需要事先配置DNS和DHCP服务，GNS  VIP可以绑定在任意一个节点的Public网卡上来实现GNS服务，如果没有配置GNS服务就不需要配置GNS  VIP。配置起来相对传统架构来说复杂一些，所以，在Oracle 11g RAC架构中很少会看到GNS VIP。12c Flex  Cluster架构必须配置GNS VIP。

## **HAIP**

在Oracle 11.2.0.2之前，私网的冗余一般是通过在OS上做网卡绑定（如Bond等）来实现的，从Oracle 11.2.0.2版本开始推出HAIP（Highly Available IP）技术替代了操作系统层面的网卡绑定技术，功能更强大、更兼容。HAIP通过其提供的独特的`169.254.*`​网段的IP地址实现集群内部链接的高可用及负载均衡。所以，在11.2.0.2或更高版本安装RAC的时候需要注意`169.254.*`​的IP地址不能被占用。有了HAIP技术则可以不再需要借助任何第三方的冗余技术来实现私网网卡的冗余。

资源ora.cluster_interconnect.haip将会启动一个到四个本地HAIP地址附在Private网络适配器上（私网网卡）。通过HAIP完成Oracle RAC和ASM等内部通讯。如果某一个私有网卡物理损坏，那么该网卡上的HAIP地址会漂移到其它的可用的**私有网络**上。多个私网网卡可以在安装阶段定义，也可以在GRID配置完成之后，通过调用`$GRID_HOME/bin/oifcfg setif`​工具（命令为：oifcfg setif -global eth2/192.168.1.0:cluster_interconnect）来配置HAIP。

HAIP的个数取决于GRID激活的私网网卡的个数。如果只有1块私网网卡，那么GRID将会创建1个HAIP。如果有两块私网网卡，那么GRID将会创建两个HAIP。若超过两块私网网卡则GRID创建4个HAIP。GRID最多支持4块私网网卡，而集群实际上使用的HAIP地址数则取决于集群中最先启动的节点中激活的私网网卡数目。如果选中更多的私网网卡作为Oracle的私有网络，那么多余4个的不能被激活。

管理ora.cluster_interconnect.haip这个资源的是ohasd.bin进程，其对应的log位于**G**R**I**D**H**O**M**E **/** l**o**g **/** HOSTNAME/ohasd/ohasd.log以及**G**R**I**D**H**O**M**E **/** l**o**g **/** HOSTNAME/agent/ohasd/orarootagent_root/orarootagent_root.log这两个位置。需要注意的是，从Oracle 12c开始，集群的告警日志已经归于ADR中，目录位置在**G**R**I**D**B**A**S**E **/** d**i**a**g**/HOSTNAME/crs/trace中，可以使用adrci命令来查看：

```bash
[root@raclhr-19c-n1 ~]# adrci

ADRCI: Release 19.0.0.0.0 - Production on Tue Mar 2 15:31:08 2021

Copyright (c) 1982, 2019, Oracle and/or its affiliates.  All rights reserved.

ADR base = "/u01/app/grid"
adrci> show home
ADR Homes: 
diag/asmcmd/user_oracle/raclhr-19c-n1
diag/asmcmd/user_grid/raclhr-19c-n1
diag/kfod/raclhr-19c-n1/kfod
diag/tnslsnr/raclhr-19c-n1/listener
diag/tnslsnr/raclhr-19c-n1/listener_scan2
diag/tnslsnr/raclhr-19c-n1/asmnet1lsnr_asm
diag/tnslsnr/raclhr-19c-n1/listener_scan3
diag/tnslsnr/raclhr-19c-n1/listener_scan1
diag/asm/+asm/+ASM1
diag/rdbms/_mgmtdb/-MGMTDB
diag/clients/user_root/host_4079108462_110
diag/clients/user_grid/host_4079108462_110
diag/crs/raclhr-19c-n1/crs

[root@raclhr-19c-n1 trace]# pwd
/u01/app/grid/diag/crs/raclhr-19c-n1/crs/trace
[root@raclhr-19c-n1 trace]# ll *ohasd*
-rw-rw---- 1 root oinstall  1358974 Mar  2 15:32 ohasd_cssdagent_root.trc
-rw-rw---- 1 root oinstall   262948 Mar  2 15:32 ohasd_cssdagent_root.trm
-rw-rw---- 1 root oinstall  1323737 Mar  2 15:32 ohasd_cssdmonitor_root.trc
-rw-rw---- 1 root oinstall   256254 Mar  2 15:32 ohasd_cssdmonitor_root.trm
-rw-rw---- 1 grid oinstall  2213526 Mar  2 15:32 ohasd_oraagent_grid.trc
-rw-rw---- 1 grid oinstall   405923 Mar  2 15:32 ohasd_oraagent_grid.trm
-rw-rw---- 1 root oinstall 17569942 Mar  2 15:32 ohasd_orarootagent_root.trc
-rw-rw---- 1 root oinstall  2998382 Mar  2 15:32 ohasd_orarootagent_root.trm
-rw-rw---- 1 root oinstall  7550545 Mar  2 15:32 ohasd.trc
-rw-rw---- 1 root oinstall  1170542 Mar  2 15:32 ohasd.trm

```

在HAIP资源online以后，通过操作系统命令ifconfig  -a就能查看到多了类似于eth1:1的虚拟网卡，HAIP地址为169.254.X.X。当然也可以在数据库级别通过GV$CLUSTER_INTERCONNECTS视图查看HAIP的地址。HAIP对应的地址由系统自动分配，无法由用户手工进行指定。

```bash
SQL> select * from GV$CLUSTER_INTERCONNECTS;

   INST_ID NAME            IP_ADDRESS                                     IS_ SOURCE                              CON_ID
---------- --------------- ---------------------------------------------- --- ------------------------------- ----------
         2 ens37:1         169.254.12.150                                 NO                                           0
         1 ens37:1         169.254.15.64                                  NO                                           0
```

**Oracle数据库**和ASM实例可以通过HAIP来实现私网通讯的高可用性和负载均衡。私网的流量会在这些私网网卡上实现负载均衡，如果某个网卡出现了故障，它上面的HAIP会自动切换到别的可用的私网网卡上，从而不影响私网的通讯。**Windows**平台目前不支持HAIP技术。

但是，在有些客户环境下，私网是通过VLAN划出来的，而出于网络管理要求，VLAN的IP地址与网卡必须是绑定的，私网IP也必须是固定的IP地址（虽然按Oracle RAC的安装要求，私网应该是独立隔离的网络），这时HAIP会无法分配，导致依赖它的ASM资源无法启动。HAIP存在不少Bug，若不幸碰到，则可以将HAIP功能禁用掉。麦老师目前已经碰到过2次了，而且查原因查了很久，惭愧啊。

如果用户使用的是操作系统级别的绑定或者没有使用私网的绑定，那么可以通过在RDBMS和ASM的参数文件中设置cluster_interconnect指定私网地址将HAIP覆盖（如果有多个私网地址，请用英文冒号分隔）。虽然说HAIP本身依然存在，但是ASM实例和RDBMS实例以后就不会使用HAIP。

```bash
-- 修改DB参数
alter system set cluster_interconnects="192.168.2.52" scope=spfile sid='rac19c1';
alter system set cluster_interconnects="192.168.2.53" scope=spfile sid='rac19c2';

-- 修改ASM参数
alter system set cluster_interconnects="192.168.2.52" scope=spfile sid='+ASM1';
alter system set cluster_interconnects="192.168.2.53" scope=spfile sid='+ASM2';


-- 重启集群
crsctl stop has -f
crsctl start has


-- DB和ASM查询
SQL> select * from GV$CLUSTER_INTERCONNECTS;

   INST_ID NAME            IP_ADDRESS                                     IS_ SOURCE                              CON_ID
---------- --------------- ---------------------------------------------- --- ------------------------------- ----------
         2 ens37           192.168.2.53                                   NO  cluster_interconnects parameter          0
         1 ens37           192.168.2.52                                   NO  cluster_interconnects parameter          0

```

#### **禁用HAIP**

除了上边修改cluster_interconnect参数外，我们也可以选择禁用HAIP。在禁用HAIP后，ASM和DB默认使用私网的网卡地址。禁用HAIP的步骤如下所示。

使用root用户执行以下命令。

1、停止所有节点的CRS

```bash
crsctl stop crs
```

2、依次在每个节点中执行以下命令（节点1执行完毕以下所有命令后再在节点2执行）

```javascript
crsctl start crs -excl -nocrs
crsctl stop res ora.asm -init
crsctl modify res ora.cluster_interconnect.haip -attr "ENABLED=0" -init
crsctl modify res ora.asm -attr "START_DEPENDENCIES='hard(ora.cssd,ora.ctssd)pullup(ora.cssd,ora.ctssd)weak(ora.drivers.acfs)',STOP_DEPENDENCIES='hard(intermediate:ora.cssd)'" -init
crsctl stop crs
```

说明，ora.cluster_interconnect.haip的ENABLED属性的原始值为1：

```bash
ENABLED=1
```

ora.asm资源的START_DEPENDENCIES和STOP_DEPENDENCIES的原始值为：

```bash
START_DEPENDENCIES=hard(ora.cssd,ora.ctssd)pullup(ora.cssd,ora.ctssd)weak(ora.cluster_interconnect.haip,ora.drivers.acfs)
STOP_DEPENDENCIES=hard(intermediate:ora.cssd,shutdown:ora.cluster_interconnect.haip)
```

3、依次在每个节点启动CRS

```javascript
crsctl start crs
```

4、检查HAIP是否禁用

```javascript
crsctl stat res -t -init
```

若ora.cluster_interconnect.haip为offline则为禁用状态。

```javascript
ora.cluster_interconnect.haip
      1        ONLINE  OFFLINE                               STABLE
```

然后执行如下命令：

```javascript
ifconfig -a 或ip a |grep 169.254
```

查看是否还有169.254开头的地址，如果没有了，那么说明已经禁用成功。

下面给出查看资源的属性值的命令：

```javascript
[root@rac2 ~]# crsctl stat res ora.cluster_interconnect.haip  -p -init | grep ENABLED
ENABLED=0
[root@rac2 ~]# crsctl stat res ora.asm  -p -init | grep START_DEPENDENCIES
START_DEPENDENCIES=hard(ora.cssd,ora.ctssd)pullup(ora.cssd,ora.ctssd)weak(ora.drivers.acfs)
[root@rac2 ~]# 
[root@rac2 ~]# crsctl stat res ora.asm  -p -init | grep STOP_DEPENDENCIES 
STOP_DEPENDENCIES=hard(intermediate:ora.cssd)
```

若启用HAIP，则过程和禁用的过程一致，其主要修改命令如下：

```javascript
crsctl modify res ora.cluster_interconnect.haip -attr "ENABLED=1" -init
crsctl modify res ora.asm -attr "START_DEPENDENCIES='hard(ora.cssd,ora.ctssd)pullup(ora.cssd,ora.ctssd)weak(ora.cluster_interconnect.haip,ora.drivers.acfs)',STOP_DEPENDENCIES='hard(intermediate:ora.cssd,shutdown:ora.cluster_interconnect.haip)'" -init
```
