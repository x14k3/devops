# iperf3

iPerf3是用于主动测量IP网络上最大可达到带宽的工具。它支持与时序，缓冲区和协议（TCP，UDP，带有IPv4和IPv6的SCTP）相关的各种参数的调整。对于每个测试，它都会报告带宽，损耗和其他参数。y

‍

```bash
# 服务端（流量接收端）
iperf3 -s -p 5201 -D

# 客户端（流量发送端）
iperf3 -c 192.168.1.s -p 5201 -f M -t 60 -b 100M -Z --logfile /tmp/perf3_client.log
```

## 命令说明

### 通用参数

|命令行参数|描述说明|
| ------------------------| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|-p, --port n|1、服务端：服务端监听的端口，默认5201端口，同时监听TCP/UDP<br />2、客户端：客户端去连接的端口，默认5201，如果同时有-u参数，则用UDP发起连接，如果没有，则默认使用TCP连接<br />使用方式：<br />iperf3 -s -p 6666, 在6666端口监听<br />iperf3 -c 192.168.0.1 -p 6666, 去连接服务端的6666端口<br />|
|--cport n|本参数提供了一个指定客户端本地端口的选项，区分于-p指定的是服务端的远端端口<br />使用方式：<br />iperf3 -s --cport 8888, 在服务端指定客户端本地端口只能是8888？ 从测试结果看，这个选项在服务端不起任何作用，但执行命令不会报错<br />iperf3 -c 192.168.0.1 --cport 8888，指定客户端选择本地端口为8888<br />|
|-f, --format [kmKM]|指定打印测试结果的带宽（bitrate比特率这一列）时用什么格式显示:k表示：千比特/秒， K表示：千字节/秒， m表示：兆比特/秒， K表示：兆字节/秒。<br />客户端和服务端可以用不同的参数，各自按照各自指定的方式打印出带宽测试结果<br />使用方式：<br />iperf3 -s -f M<br />iperf3 -c 192.168.0.1 -f k<br />|
|-i, --interval n|以秒为单位，设置带宽（还有抖动，丢包等）测试报告打印输出的周期。不使用这个选项时，默认周期是1秒，可以使用0和任何0.1秒到60秒之间的参数，如果是0表示不打印周期性的报告，只在整个测试完成时，输出一次报告结果。<br />（上面英文解释说默认值是0这个是错误的，默认值实际上是1），客户端和服务端可以使用不同的参数值。<br />使用方式：<br />iperf3 -s -i 0<br />iperf3 -c 192.168.0.1 -i 3.6<br />|
|-F, --file name|客户端：从文件中读取数据，并发送到网络里，如果不加这个选项默认系统会产生随机数据发送到网络里<br />服务端：把网络上收到的数据写入文件中，默认系统会丢弃收到的数据<br />文件格式未知，在google上也找不到什么说明，待后续更新()<br />使用方式：<br />iperf3 -s -F ./log.txt<br />iperf3 -c 192.168.0.1 -F ./input.txt<br />|
|-A, --affinity n/n,m-F|如果系统支持则可以设置CPU亲和性（只支持Linux和FreeBSD），说白了就是在设定将iperf3进程跑在哪个CPU上。<br />客户端和服务端都可以设置CPU亲和性,n表示CPU编号（Linux下如何查看CPU编号及其它CPU相关的信息）。<br />此外在客户端可以通过"-A n,m"的形式，覆盖server端的CPU亲和性设置（就是覆盖运行server端时，指定运行在哪个CPU上的设置），指定本次运行时iperf3的服务端跑在m号CPU上，但只对这一次运行生效。<br />注意如果用了这个参数，意味着iperf3只会在指定的CPU上运行（默认不加这个参数时，操作系统会自行调度CPU，负荷重（加多线程？）有可能会把iperf3同时运行在多个CPU上）<br />使用方式：<br />iperf3 -s -A 2，指定服务端运行在2号CPU上<br />iperf3 -c 192.168.0.1 -A 0，指定客户端运行在0号CPU上<br />或者<br />iperf3 -c 192.168.0.1 -A 0,3，指定本次运行客户端运行在0号CPU上而服务端运行在2号CPU上<br />|
|-B, --bind host|绑定到主机，主机的一个地址。对客户端来说，这个设置数据发送从哪个接口发送。<br />对服务端来说，这是设置数据从哪个接口接收。这个命令只在多宿主主机（二个或者二个以上网络接口）中有用。<br />这个选项对接口的定义很不清楚，没有讲清楚 IP接口和物理网卡接口选择时，-B与主机路由的选择关系，<br />可以参照另外一个文章有清楚的描述：iPerf3 -B (--bind host)绑定发送端网卡/发送IP端地址<br />|
|-V, --verbose|输入更多的详细信息<br />|
|-J, --json|运行结束时，用JSON的格式输出测试结果，默认打印到屏幕上，可以结合下面"--logfile"或者linux本身的重定向命令">"将输出报告打印到指定文件里<br />|
|--logfile file|把测试结果存到指定的log文件<br />|
|-d, --debug|打印出更多的调试用的log，主要是给开发者用的，如果不是碰到需要调试的问题，这个参数基本没什么用。<br />|
|-v, --version|只要加了-v这个参数，iperf3会显示版本号，然后自动退出<br />|
|-h, --help|只要加了-h这个参数，iperf3会显示帮助信息(包括命令使用格式，各个参数的简明的使用说明)，然后自动退出-Z<br />|

### 服务器端专用参数

|命令行参数|具体描述<br />|
| -------------------| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|-s, --server|本次iperf3运行在服务端模式（-c和-s是互斥的，二者必居其一），括号里的这句话：这只允许一次一个iperf connection，是指iperf服务端同一时间只接受一个TCP或者UDP连接。<br />意味着同一时间只有一个客户端可以给这个iperf3服务端进程打流。（但可以在通过-p参数，指定在同一个主机的同一个IP地址的不同的端口同时开多个iperf3服务端进程）<br />使用方式：<br />iperf3 -s<br />|
|-D, --daemon|以daemon的形式在后台运行(不会向控制台窗口输出，可以通过ps -aux 竖符号 grep iperf3看到对应的后台进程号)<br />和用iperf3 -s &命令（注意命令最后的&号）类似，都可以让iperf3在后台运行，但iperf3 -s &命令的话，控制台终端还是可以得到iperf3的打印输出的。<br />但用&的后台运行，在你关闭终端时，程序也会关闭，而用-D的，则在终端关闭后，iperf3 -s会继续在后台运行。<br />下面文章可以详细了解Linux前后台程序，如何让程序在后台运行，如何切换前后台，以及Daemon进程：<br />如何在Linux前后台切换程序, 用&把程序运行在后台和以Daemon方式运行的程序（控制台退出后程序继续保持运行）<br />使用方式:<br />iperf3 -s -D<br />|
|-I, --pidfilefile|这介需要iperf3.1以上版本才支持，提供了一个将本次运行的iperf3进程的PID写入到指定文件里的功能，正常的情况下也没啥用，大概率在将程序运行成Daemon程序，<br />并用需要通过PID去监控，KILL或者其它控制这个进程的自动化功能时用到（原文件是这么说的，但我觉得这个指供的功能和ps -aux 竖符号 grep iperf3得到的信息是一样的，<br />对于工作在Linux下的人来说并没有什么实际意义，估计是给其它平台的工作者用的）<br />使用方式：<br />iperf3 -s -I /home/user/iperf.pid<br />注意：<br />1）当前用户一定要有/home/user目录的写权限<br />2）文件可以事先用touch命令创建好，也可以不用创建<br />3）iperf3当前进各结束后/home/user/iperf.pid文件会被主动删除<br />4）/home/user/iperf.pid一定要使用全路径，不能使用默认的当前路径<br />（使用当前路径分导致各种奇怪的iperf启动失败，或者启动成功了，但指定目录找到不iperf.pid文件），原因不明<br />|

### 客户端专用参数

|命令行参数|具体描述|
| -----------------------------| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|-c, --client host|本次iperf3运行在客户端状态，host指向的是iperf服务端的ip地址<br />使用方式:<br />iperf3 -c 192.168.0.10, 本机做为客户端连接到192.168.0.10(服务端运行在这人ip地址上)，并做打流量测试<br />|
|--sctp|使用sctp协议（不加这人选项的话默认使用tcp），iperf3.1及更新的版本开始支持<br />使用方式:<br />iperf3 -c 192.168.0.10 --sctp<br />|
|-u, --udp|使用udp协议（不加这人选项的话默认使用tcp），使用这个选项的话，还需要查看-b选项，因为UDP是面向数据报的协议，所以一般要用-b指定打多大带宽的数据(不指定-b的话，默认值见对-b参数的解释)<br />使用方式:<br />iperf3 -c 192.168.0.10 -u<br />|
|-b, --bandwidth n[KM]|设置本次测试的发送带宽成n 比特/秒（对UDP来说默认是1M 比特/秒，对TCP来说默认是不限制），如果同时还设置了多线程(-P选项)，当前这个-b的带宽指定的是每个线程的发送带宽。<br />我们还可以在带宽后面加上/和一个数字。我们称这个为“突发脉冲模式”。加了这个“/数字”后，iperf3客户端会一次连续发送指定的数量的数据包，中间不做任何间隔（不加这个 "/数字"时，iperf3会根据每个报文的长度，算出为了达到指定的带宽，每秒需要发送几个报文，然后每个数据报文会被以平均的时间间隔进行发送），即使中间会有偶尔的超出带宽限制<br />使用方式:<br />iperf3 -c 192.168.0.10 -u -b 100M，报文平均的落在时间线上<br />或者<br />iperf3 -c 192.168.0.10 -u -b 100M/40，报文以40个为一组，连续发送40个报文，每一组平均的落在时间线上，每一组发送时可能超出-b指定的带宽，但iperf3保证整个打流期间的平均带宽不超过指定值。<br />详见：iperf3 -b参数详细图文分析<br />|
|-t, --time n|定义本次发送报文测试要持续的时间，单位为秒iPerf通常工作的模式是：持续-t定义的时间（秒）不停的重复发送一组长度为-l定义的数据包。默认值是10秒。参照-l, -k和-n选项<br />使用方式：<br />iperf3 -c 127.0.0.1 -u -t 11<br />注意这个参数不能和-n或者-k同时使用，上述例子表示连续发送11秒钟时间后停止测试<br />|
|-n, --num n[KM]|定义本次发送报文要发送的总的数据长度，单位是字节。默认情况下iperf持续发送10秒时间。加了-n选项后，就不覆盖了10秒这个默认设置，而是发送-n指定长度的数据,发送完后停止。参照-l,-k和-t选项<br />使用方式：<br />iperf3 -c 127.0.0.1 -u -n 40M<br />注意这个参数不能和-t或者-k同时使用,长度后面不带单位的话默认单位是字节，也可以用K/M表示千/兆字节，上述例子表示总共要发送40M字节的报文<br />|
|-k, --blockcount n[KM]|定义本次发送报文要发送的报文个数。发送-k指定个数的报文,发送完后停止。参照-l,-n和-t选项<br />使用方式：<br />iperf3 -c 127.0.0.1 -u -k 37<br />注意这个参数不能和-t或者-n同时使用,上面例子表示总共要发送37个报文<br />|
|-l, --length n[KM]|每次发报的报文长度。iperf发送一组长度为-l指定的数据报文，每个数据报文的长度都是-l指定的长度。默认TCP是128KB, UDP是8KB。参照-n, -k和-t选项。<br />使用方式:<br />iperf3 -c 192.168.3.15 -u -l 2K<br />注意: 这个参数可以和-n, -k和-t参数一起使用。<br />|
|-P, --parallel n|到iperf3服务器端并行的连接数量，默认值是1。（未知并行这个参数其实不是个多线程？这个需要看原代码。如果不是多纯种那么很奇怪为什么多线程在某些测试过程中能测出更大的带宽？）<br />使用方式:<br />iperf3 -c 192.168.3.15 -u -P 3<br />表示开3个连接，这里可以查看链接文章：如何查看LINUX里的某个进程的线程<br />|
|-R, --reverse|工作在反向连接模式（服务器端发送，客户端接收）<br />使用方式：<br />iperf3 -c 192.168.3.15 -u -R<br />|
|-w, --window n[KM]|设置socket缓冲的大小。对TCP来说，这个用于设置 TCP 窗口接收的大小（这个选项会被发送到服务器端，同样的参数会在服务器端生效）<br />iperf3 -c 192.168.3.15 -w 100k<br />对于UDP来说，通常不需要设置这个参数，这个数设置得太小了，会导致发送端发送速度慢，<br />对于TCP来说，这个参数的设置值的计算和选择方法详见：TCP滑动窗口协议与窗口大小的计算<br />|
|-M, --set-mss n|尝试去设置TCP的MSS最大分片长度。MSS通常是MTU减去40字节的TCP/IP首部。对以达网来说MSS是1460（MTU是1500字节）<br />使用方式：<br />iperf3 -c 192.168.3.15 -M 100<br />MSS设置得很小，会导致TCP分成很多个小包进行发送，过小会导致带宽测试结果偏小。<br />详见：TCP的MSS的计算与详解<br />|
|-N, --no-delay|设置TCP的不延时选项，关闭Nagle's算法，通常这个选项只用于交互式人机对话的应用程序中，比如Telnet<br />使用方式：<br />iperf3 -c 192.168.3.26 -N<br />|
|-4, --version4|只使用IPv4<br />|
|-6, --version4|只使用IPv6, 注意这个要配合IPv6的地址一起使用<br />|
|-S, --tos n|设置被发送出去的报文的TOS字段。(目前很多路由器是不处理TOS字段的)，可以用0x打头输入16进制数，0打头输入8进制数，或者不需要前缀则默认是10进制数。<br />比如: 16进制的"0x10"表示8进制的"020"表示十进制的16。<br />TOS定义如下：<br />使用方式：<br />iperf3 -c 192.168.3.15 -S 0x10<br />|
|-L, --flowlabel n|设置IPv6的流标签（目前只有Linux版本的iperf3能支持）<br />|
|-Z, --zerocopy|使用“零拷贝”办法来发送数据，比如使用sendfile(2)代替write(2).这会减少CPU的占用率<br />使用方式：<br />iperf3 -c 192.168.3.15 -u -Z<br />|
|-O, --omit n|忽略最前面n秒的测试结果，通常用来跳过TCP慢启动过程<br />使用方式：<br />iperf3 -c 192.168.3.15 -O 20 -t 40<br />忽略最前面的20秒，然后再打40秒的流(见-t参数)<br />详见：TCP慢启动过程详解<br />|
|-T, --title str|每行打印输出内容前加一个前缀<br />使用方式：<br />iperf3 -c 192.168.3.15 -T 这是前缀<br />在每行输入前面加了“这是前缀”这4个字，不知道这个功能有什么用<br />|
|-C, --linux-congestion algo|设置TCP拥塞控制算法(在LINUX上3.0以上支持，在LINUX和FREEBSD上3.1以下版本支持)|
